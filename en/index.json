[{"content":" 🙋‍♂️ Hi there # I\u0026rsquo;m Max Qian. I have a passion for astronomy and programming, and am committed to developing open-source astronomical software.\n🤔 Exploring new technologies and developing software solutions and quick hacks.\n🌱 Learning about Systems Design and Advanced Algorithms.\n✍️ Pursuing C++ Development and Competitive Programming as hobbies/side projects.\n\u0026#x2b50; Mainly researching software in the field of astronomy\n- 🛠 Tech Stack # Programming Languages # APIs # Tools # IDE # ","externalUrl":null,"permalink":"/zh-cn/about/","section":"Max Qian's blog","summary":"\u003ch1 class=\"relative group\"\u003e🙋‍♂️ Hi there \n    \u003cdiv id=\"-hi-there\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#-hi-there\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003c!--   my-icons --\u003e\n\u003cp align=\"center\"\u003e\n    \u003ca href=\"https://github.com/AstroAir\"\u003e\u003cimg src=\"https://img.shields.io/badge/status-updating-brightgreen.svg\"\u003e\u003c/a\u003e\n    \u003cimg src=\"https://visitor-badge.laobi.icu/badge?page_id=AstroAir.AstroAir\" alt=\"visitors\"/\u003e\n\u003c/p\u003e\n\u003c!--   my-ticker --\u003e\n\u003cp\u003e\u003ca href=\"https://git.io/typing-svg\" target=\"_blank\"\u003e\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"https://readme-typing-svg.herokuapp.com?color=%2336BCF7\u0026amp;center=true\u0026amp;vCenter=true\u0026amp;width=600\u0026amp;lines=Hi\u0026#43;there\u0026#43;%f0%9f%91%8b,\u0026#43;I\u0026#43;am\u0026#43;Max\u0026#43;Qian;\u0026#43;Welcome\u0026#43;to\u0026#43;My\u0026#43;Profile!\" alt=\"Typing SVG\" /\u003e\n    \n  \u003c/figure\u003e\n\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m Max Qian. I have a passion for astronomy and programming, and am committed to developing open-source astronomical software.\u003c/p\u003e","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/zh-cn/cpp/","section":"Cpps","summary":"","title":"Cpps","type":"cpp"},{"content":"","externalUrl":null,"permalink":"/zh-cn/c/","section":"Cs","summary":"","title":"Cs","type":"c"},{"content":"大家好啊，欢迎来到 C 语言的世界！作为一个入门者，你即将踏上一段有趣的编程旅程。而我们要做的第一件事，就是写出一个无比经典且简单的程序——\u0026ldquo;Hello, World!\u0026quot;。准备好了吗？带上你的大脑和电脑（如果是手机超人也可以），我们要出发咯！\n最难的问题：Hello World # 程序员调查表明，Hello, World 劝退很多新人，如果你能越过这道坎，那么你已经击败了 50%的萌新了 awa\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 冒险启程 # 引入主角：#include \u0026lt;stdio.h\u0026gt; # 一切编程冒险的开始，往往需要介绍主角。#include \u0026lt;stdio.h\u0026gt;，就像是你打开了大门，邀请了 C 语言的图书管理员进来。这个图书管理员叫做 stdio.h，全名是“标准输入输出头文件”，它会帮你处理所有输入输出的操作。\n问题：为什么要请这个图书管理员？ 答案：因为你马上要用到它的宝贝——printf 函数，来把“Hello, World!”打印到屏幕上。如果没有它，printf 就无家可归，根本用不了。 主办方出场：int main() # 然后，我们的主办方登场了：int main()。这就是你程序的“大老板”，相当于所有代码的起点，所有程序都必须从这里开始执行。主办方全程监督你的程序，不管你有多少代码，都得从这里开始运行。\n问题：为什么是 int 类型？ 答案：因为在 C 语言里，main 函数必须给操作系统打个招呼，告诉它程序运行完后是成功了，还是出问题了。int 类型表示返回一个整数，0 表示“一切顺利，没毛病”，其他数字则意味着“嗯，有点小问题”。 打印操作：printf(\u0026quot;Hello, World!\\n\u0026quot;); # 接下来就是本次冒险的重头戏了！printf(\u0026quot;Hello, World!\\n\u0026quot;);。printf 函数就像是一个巨大的喇叭，它会大声宣布：“Hello, World!”。\n问题：为什么有个\\n？ dark 案：这个神秘的\\n 是一个控制符，表示“换行”。就好像你在纸上写字，写完一句话，换行再写下一句。如果没有它，你的输出就会一行连着一行，显得有点凌乱。 礼貌的告别：return 0; # 最后，主办方 main 函数礼貌地对操作系统说：“感谢光临，一切顺利！”通过 return 0;这句话，你告诉操作系统，程序没有出错，可以放心关闭。这是一种好习惯，因为虽然你不告诉它也能运行，但你得有礼貌嘛，是吧？\n编译与运行：是时候展示真正的实力了 # 写完代码可不意味着工作结束了！你还得把这段文字转化为计算机能懂的“机器语言”。这是通过编译器来完成的。\n编译命令 # GCC # gcc helloworld.c -o helloworld 这句话告诉编译器：“把 helloworld.c 这个文件编译成名为 helloworld 的可执行文件。”\n运行程序 # ./helloworld MSVC # 直接点编译和运行按钮\n这时，计算机会乖乖地在屏幕上显示：“Hello, World!”\n拆包 # 头文件 # 什么是头文件？ # 头文件其实是一些已经写好的 C 语言代码的集合，通常以.h 结尾。你可以把它理解为一份“说明书”，当你需要用某个功能时，头文件就告诉编译器如何找到和使用这个功能。\n举个栗子：\nstdio.h：包含标准输入输出函数，比如printf、scanf等。 stdlib.h：包含内存分配、程序控制、随机数等函数。 math.h：包含数学函数，比如sin、cos、sqrt等。 如何引入头文件？ # 我们使用预处理指令#include来引入头文件。举个例子：\n#include \u0026lt;stdio.h\u0026gt; 这个指令告诉编译器：在编译这段代码时，先把 stdio.h 的内容包含进来，以便程序中可以使用它的功能.\n系统头文件和自定义头文件 # 系统头文件：放在尖括号\u0026lt; \u0026gt;里面，编译器知道去系统目录找这些文件。例如： #include \u0026lt;stdio.h\u0026gt; 自定义头文件：如果你自己写了一个头文件，需要用双引号\u0026rdquo; \u0026ldquo;包含，编译器会在你的项目目录里找。例如： #include \u0026#34;myheader.h\u0026#34; 主函数 # int main(int argc, char *argv[]) { // 使用命令行参数的代码 return 0; } 参数: argc：表示命令行参数的个数。argv[]：是一个字符串数组，存储命令行传入的参数。一般情况下可以不写 返回值类型 int：main()函数返回一个整数类型的数据。这个返回值通常用来告诉操作系统程序的执行结果。返回 0 意味着程序成功执行，非零值则表示程序有问题。 函数体：花括号{}里面就是你程序的逻辑。你可以把所有需要执行的代码都写在这里。 return 0;：return 语句告诉操作系统程序执行完毕了。返回 0 表示成功。虽然对于小程序可以不写 return 0;，但这是个好习惯。 C++用户请注意，写 return 0;并不是好习惯，并不被推荐！\n输出 # printf()函数是 C 语言中最常用的输出函数，它的作用是将数据打印到标准输出（通常是屏幕）。printf()函数由stdio.h头文件提供。\nprintf()的基本用法 # printf(\u0026#34;Hello, World!\\n\u0026#34;); 这个函数会将双引号内的字符串输出到屏幕上。printf()可以输出不同类型的数据，具体的输出格式由格式化占位符决定。\n常用的格式化占位符 # %d：输出整数（int 类型）。 %f：输出浮点数（float、double 类型）。 %c：输出单个字符。 %s：输出字符串（字符数组）。 int age = 25; float height = 5.9; printf(\u0026#34;I am %d years old and %.1f feet tall.\\n\u0026#34;, age, height); I am 25 years old and 5.9 feet tall. 转义字符 # 转义字符是用于表示某些特殊字符的，例如换行、制表符等。\n\\n：换行符。 \\t：制表符，相当于插入了一个“跳格”。 \\：输出反斜杠\\本身。 printf(\u0026#34;Hello,\\nWorld!\\tTabbed!\\n\u0026#34;); Hello, World! Tabbed! 关于 puts（另一种输出） # puts(\u0026#34;This line is printed using puts(), and it automatically adds a newline.\u0026#34;); 请注意 puts 并不被推荐使用，完全不如 printf，以下是不使用的原因\n自动添加换行符: puts()函数的一个显著特征是它会自动添加换行符。这在某些简单的场景下很方便，但在更复杂的程序中，往往并不符合预期。 无法处理格式化输出: puts()只能打印单一的字符串，并且不支持格式化输出（如插入变量、控制输出精度等）。 缺少错误处理: puts()在失败时通常返回一个非负值（EOF 表示错误），但它并不会提供详细的错误信息。 完整的代码 # 在线编译器代码测试\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { // 1. 使用 printf 输出到屏幕 printf(\u0026#34;Hello, World! This is printed using printf().\\n\u0026#34;); // 2. 使用 puts 输出到屏幕 puts(\u0026#34;This line is printed using puts(), and it automatically adds a newline.\u0026#34;); // 3. 使用 putchar 输出单个字符到屏幕 putchar(\u0026#39;A\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); return 0; } 总结 # “Hello, World!”虽然只是个简单的小程序，但它背后涉及了很多 C 语言的基本概念：头文件、函数、语句、控制符、返回值、编译运行……别看它简单，这可是每个程序员的“开门钥匙”。 所以，恭喜你！迈出了编程世界的第一步。只要记住，每一个复杂的程序都源于这种小小的 printf，就像每一篇大作都是从一个字开始的！ 从此，编程之路正式开启，未来你还会学到更多神奇的东西，比如条件判断、循环、指针等等。不过别急，慢慢来，一切都会明朗。希望你编程愉快，bug 少少，代码美美！\n","externalUrl":null,"permalink":"/zh-cn/c/01/","section":"Cs","summary":"\u003cp\u003e大家好啊，欢迎来到 C 语言的世界！作为一个入门者，你即将踏上一段有趣的编程旅程。而我们要做的第一件事，就是写出一个无比经典且简单的程序——\u0026ldquo;Hello, World!\u0026quot;。准备好了吗？带上你的大脑和电脑（如果是手机超人也可以），我们要出发咯！\u003c/p\u003e","title":"Day1 - \"Hello, World!\"原来也这么复杂","type":"c"},{"content":" 安装 Rust # 第一步是安装 Rust。我们将通过 rustup 下载 Rust，这是一个用于管理 Rust 版本及相关工具的命令行工具。你需要联网才能下载。\n注意： 如果出于某些原因你不想使用 rustup，请参阅 Other Rust Installation Methods 页面以获取更多选项。\n以下步骤将安装最新稳定版的 Rust 编译器。Rust 的稳定性保证确保本书中所有能够编译的示例在较新的 Rust 版本中仍然可以编译。不同版本之间的输出可能会略有不同，因为 Rust 经常改进错误信息和警告。换句话说，使用这些步骤安装的任何较新的稳定版 Rust 都应该与本书的内容兼容。\n命令行符号 # 在本章及全书中，我们将展示一些在终端中使用的命令。你应该在终端中输入的行都以 $ 开头。你不需要输入 $ 字符；它是命令行提示符，用于指示每个命令的开始。不以 $ 开头的行通常显示上一个命令的输出。此外，PowerShell 特定的示例将使用 \u0026gt; 而不是 $。\n在 Linux 或 macOS 上安装 rustup # 如果你使用的是 Linux 或 macOS，打开终端并输入以下命令：\ncurl --proto \u0026#39;=https\u0026#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh 该命令下载一个脚本并启动 rustup 工具的安装，该工具将安装最新稳定版的 Rust。你可能会被提示输入密码。如果安装成功，将出现以下行：\nRust is installed now. Great! 你还需要一个链接器，这是 Rust 用来将其编译输出合并为一个文件的程序。你可能已经有一个链接器。如果你遇到链接器错误，你应该安装一个 C 编译器，它通常会包含一个链接器。C 编译器也很有用，因为一些常见的 Rust 包依赖于 C 代码，因此需要 C 编译器。\n在 macOS 上，你可以通过运行以下命令获取 C 编译器：\nxcode-select --install Linux 用户通常应根据其发行版的文档安装 GCC 或 Clang。例如，如果你使用 Ubuntu，可以安装 build-essential 包。\n在 Windows 上安装 rustup # 在 Windows 上，访问 https://www.rust-lang.org/tools/install 并按照安装 Rust 的说明进行操作。在安装过程中的某个时刻，你将被提示安装 Visual Studio。这将提供一个链接器和编译程序所需的本地库。如果你需要更多帮助，请参阅 https://rust-lang.github.io/rustup/installation/windows-msvc.html。\n本书的其余部分使用在 cmd.exe 和 PowerShell 中都有效的命令。如果有特定的差异，我们会解释使用哪个。\n故障排除 # 要检查你是否正确安装了 Rust，请打开一个 shell 并输入以下命令：\nrustc --version 你应该看到最新稳定版本的版本号、提交哈希和提交日期，格式如下：\nrustc x.y.z (abcabcabc yyyy-mm-dd) 如果你看到这些信息，说明你已经成功安装了 Rust！如果你没有看到这些信息，请检查 Rust 是否在你的 %PATH% 系统变量中。\n在 Windows CMD 中，使用：\n\u0026gt; echo %PATH% 在 PowerShell 中，使用：\n\u0026gt; echo $env:Path 在 Linux 和 macOS 中，使用：\necho $PATH 如果这些都正确，但 Rust 仍然无法工作，你可以在多个地方寻求帮助。了解如何与其他 Rustaceans（我们对自己的一个有趣的昵称）联系，请访问 社区页面。\n更新和卸载 # 通过 rustup 安装 Rust 后，更新到新发布的版本非常简单。在你的 shell 中运行以下更新脚本：\nrustup update 要卸载 Rust 和 rustup，请在 shell 中运行以下卸载脚本：\nrustup self uninstall 本地文档 # Rust 的安装还包括一份本地文档副本，以便你可以离线阅读。运行 rustup doc 以在浏览器中打开本地文档。\n任何时候，如果你不确定标准库提供的类型或函数的作用或如何使用它，请使用应用程序编程接口（API）文档来查找答案！\n你好，世界 # 现在你已经安装了 Rust，是时候编写你的第一个 Rust 程序了。学习新语言时，传统上会编写一个在屏幕上打印 Hello, world! 的小程序，所以我们在这里也这样做！\n注意： 本书假设你对命令行有基本的了解。Rust 对你的编辑器、工具或代码存放位置没有特定要求，因此如果你更喜欢使用集成开发环境（IDE）而不是命令行，请随意使用你喜欢的 IDE。许多 IDE 现在都有一定程度的 Rust 支持；请查看 IDE 的文档以获取详细信息。Rust 团队一直致力于通过 rust-analyzer 提供出色的 IDE 支持。更多详情请参见附录 D。\n创建项目目录 # 首先，你需要创建一个目录来存放你的 Rust 代码。Rust 并不关心你的代码存放在哪里，但为了本书的练习和项目，我们建议在你的主目录下创建一个 projects 目录，并将所有项目存放在那里。\n打开终端并输入以下命令，以在 projects 目录下创建一个 projects 目录和一个用于“Hello, world!”项目的目录。\n对于 Linux、macOS 和 Windows 上的 PowerShell，请输入以下内容 # mkdir ~/projects cd ~/projects mkdir hello_world cd hello_world 对于 Windows CMD，请输入以下内容 # \u0026gt; mkdir \u0026#34;%USERPROFILE%\\projects\u0026#34; \u0026gt; cd /d \u0026#34;%USERPROFILE%\\projects\u0026#34; \u0026gt; mkdir hello_world \u0026gt; cd hello_world 编写并运行 Rust 程序 # 接下来，创建一个新的源文件并将其命名为 main.rs。Rust 文件总是以 .rs 扩展名结尾。如果你在文件名中使用多个单词，惯例是使用下划线来分隔它们。例如，使用 hello_world.rs 而不是 helloworld.rs。\n现在打开你刚刚创建的 main.rs 文件，并输入清单 1-1 中的代码。\n文件名： main.rs\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); } 清单 1-1： 一个打印 Hello, world! 的程序\n保存文件并返回到 ~/projects/hello_world 目录中的终端窗口。在 Linux 或 macOS 上，输入以下命令来编译并运行文件：\nrustc main.rs ./main Hello, world! 在 Windows 上，输入命令 .\\main.exe 而不是 ./main：\n\u0026gt; rustc main.rs \u0026gt; .\\main.exe Hello, world! 无论你的操作系统是什么，字符串 Hello, world! 都应该打印到终端。如果你没有看到这个输出，请参考安装部分的“故障排除”部分以获取帮助。\n如果 Hello, world! 打印出来了，恭喜你！你已经正式编写了一个 Rust 程序。这使你成为了一名 Rust 程序员——欢迎加入！\nRust 程序的结构 # 让我们详细回顾一下这个“Hello, world!”程序。以下是第一个关键部分：\nfn main() { } 这些行定义了一个名为 main 的函数。main 函数是特殊的：它始终是每个可执行 Rust 程序中首先运行的代码。在这里，第一行声明了一个名为 main 的函数，它没有参数且不返回任何内容。如果有参数，它们将放在括号 () 内。\n函数体用 {} 包裹。Rust 要求所有函数体都用花括号括起来。将左花括号放在函数声明的同一行，并在两者之间添加一个空格，这是一种良好的风格。\n注意： 如果你想在 Rust 项目中坚持标准风格，可以使用一个名为 rustfmt 的自动格式化工具来以特定风格格式化你的代码（更多关于 rustfmt 的内容请参见附录 D）。Rust 团队已经将这个工具包含在标准 Rust 发行版中，就像 rustc 一样，所以它应该已经安装在你的电脑上了！\nmain 函数的主体包含以下代码：\nprintln!(\u0026#34;Hello, world!\u0026#34;); 这行代码在这个小程序中完成了所有工作：它将文本打印到屏幕上。这里有四个重要的细节需要注意。\n缩进： Rust 风格是使用四个空格进行缩进，而不是制表符。 宏调用： println! 调用了一个 Rust 宏。如果它调用的是一个函数，那么它将输入为 println（没有 !）。我们将在第 19 章详细讨论 Rust 宏。现在，你只需要知道使用 ! 意味着你正在调用一个宏而不是普通函数，并且宏并不总是遵循与函数相同的规则。 字符串参数： 你看到了 \u0026quot;Hello, world!\u0026quot; 字符串。我们将这个字符串作为参数传递给 println!，然后字符串被打印到屏幕上。 分号： 我们以分号（;）结束这行代码，表示这个表达式结束，下一个表达式准备开始。大多数 Rust 代码行都以分号结尾。 编译和运行是分开的步骤 # 你刚刚运行了一个新创建的程序，让我们来检查一下这个过程。\n在运行 Rust 程序之前，你必须使用 Rust 编译器通过输入 rustc 命令并传递源文件的名称来编译它，如下所示：\nrustc main.rs 如果你有 C 或 C++ 背景，你会注意到这与 gcc 或 clang 类似。成功编译后，Rust 会输出一个二进制可执行文件。\n在 Linux、macOS 和 Windows 上的 PowerShell 中，你可以通过在 shell 中输入 ls 命令来查看可执行文件：\nls main main.rs 在 Linux 和 macOS 上，你会看到两个文件。在 Windows 上的 PowerShell 中，你会看到与使用 CMD 时相同的三个文件。在 Windows 上的 CMD 中，你将输入以下内容：\n\u0026gt; dir /B %= /B 选项表示只显示文件名 =% main.exe main.pdb main.rs 这将显示带有 .rs 扩展名的源代码文件、可执行文件（在 Windows 上是 main.exe，但在其他平台上为 main），以及在使用 Windows 时包含调试信息的 .pdb 扩展名的文件。从这里，你可以运行 main 或 main.exe 文件，如下所示：\n./main # 或在 Windows 上为 .\\main.exe 如果你的 main.rs 是“Hello, world!”程序，这行代码将 Hello, world! 打印到你的终端。\n如果你更熟悉动态语言，如 Ruby、Python 或 JavaScript，你可能不习惯将编译和运行程序作为分开的步骤。Rust 是一种提前编译的语言，这意味着你可以编译一个程序并将可执行文件交给其他人，他们可以在没有安装 Rust 的情况下运行它。如果你给某人一个 .rb、.py 或 .js 文件，他们需要安装 Ruby、Python 或 JavaScript 实现（分别）。但在这些语言中，你只需要一个命令来编译和运行你的程序。语言设计中的一切都是权衡。\n对于简单的程序来说，仅使用 rustc 编译是可以的，但随着项目的增长，你将需要管理所有选项并使其易于共享代码。接下来，我们将向你介绍 Cargo 工具，它将帮助你编写实际的 Rust 程序。\n你好，Cargo # Cargo 是 Rust 的构建系统和包管理器。大多数 Rust 开发者使用这个工具来管理他们的 Rust 项目，因为 Cargo 为你处理了许多任务，比如构建代码、下载代码依赖的库以及构建这些库。（我们将代码所需的库称为依赖项。）\n最简单的 Rust 程序，比如我们目前编写的这个，没有任何依赖项。如果我们使用 Cargo 构建“Hello, world!”项目，它只会使用 Cargo 中处理代码构建的部分。随着你编写更复杂的 Rust 程序，你会添加依赖项，而如果你使用 Cargo 启动项目，添加依赖项会变得容易得多。\n因为绝大多数 Rust 项目都使用 Cargo，本书的其余部分也假设你正在使用 Cargo。如果你使用了“安装”部分中讨论的官方安装程序，Cargo 会随 Rust 一起安装。如果你通过其他方式安装了 Rust，可以通过在终端中输入以下内容来检查是否安装了 Cargo：\ncargo --version 如果你看到一个版本号，说明你已经安装了 Cargo！如果你看到一个错误，比如 command not found，请查看你安装方法的文档，以确定如何单独安装 Cargo。\n使用 Cargo 创建项目 # 让我们使用 Cargo 创建一个新项目，并看看它与我们最初的“Hello, world!”项目有何不同。导航回你的 projects 目录（或你决定存放代码的任何地方）。然后，在任何操作系统上运行以下命令：\ncargo new hello_cargo cd hello_cargo 第一个命令创建了一个名为 hello_cargo 的新目录和项目。我们将项目命名为 hello_cargo，Cargo 会在同名目录中创建其文件。\n进入 hello_cargo 目录并列出文件。你会看到 Cargo 为我们生成了两个文件和一个目录：一个 Cargo.toml 文件和一个包含 main.rs 文件的 src 目录。\n它还初始化了一个新的 Git 仓库，并附带了一个 .gitignore 文件。如果你在现有的 Git 仓库中运行 cargo new，则不会生成 Git 文件；你可以通过使用 cargo new --vcs=git 来覆盖此行为。\n注意： Git 是一个常见的版本控制系统。你可以通过使用 --vcs 标志来更改 cargo new 以使用不同的版本控制系统或不使用版本控制系统。运行 cargo new --help 以查看可用的选项。\n在你选择的文本编辑器中打开 Cargo.toml。它应该类似于清单 1-2 中的代码。\n文件名： Cargo.toml\n[package] name = \u0026#34;hello_cargo\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; # 更多键及其定义请参见 https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] 清单 1-2： 由 cargo new 生成的 Cargo.toml 内容\n这个文件采用 TOML（Tom\u0026rsquo;s Obvious, Minimal Language）格式，这是 Cargo 的配置格式。\n第一行 [package] 是一个部分标题，表示以下语句正在配置一个包。随着我们向该文件添加更多信息，我们将添加其他部分。\n接下来的三行设置了 Cargo 编译程序所需的配置信息：名称、版本和使用的 Rust 版本。我们将在附录 E 中讨论 edition 键。\n最后一行 [dependencies] 是一个部分的开始，用于列出项目的任何依赖项。在 Rust 中，代码包被称为 crate。我们在这个项目中不需要其他 crate，但在第 2 章的第一个项目中会需要，因此我们将在那时使用这个 dependencies 部分。\n现在打开 src/main.rs 并查看：\n文件名： src/main.rs\nfn main() { println!(\u0026#34;Hello, world!\u0026#34;); } Cargo 为你生成了一个“Hello, world!”程序，就像我们在清单 1-1 中编写的那个一样！到目前为止，我们的项目与 Cargo 生成的项目之间的区别在于，Cargo 将代码放在了 src 目录中，并且我们在顶层目录中有一个 Cargo.toml 配置文件。\nCargo 期望你的源文件位于 src 目录中。顶级项目目录仅用于 README 文件、许可证信息、配置文件以及其他与代码无关的内容。使用 Cargo 有助于你组织项目。每样东西都有其位置，每样东西都在其位置上。\n如果你启动了一个不使用 Cargo 的项目，就像我们使用“Hello, world!”项目那样，你可以将其转换为使用 Cargo 的项目。将项目代码移动到 src 目录中，并创建一个适当的 Cargo.toml 文件。获取该 Cargo.toml 文件的一种简单方法是运行 cargo init，它会自动为你创建该文件。\n构建和运行 Cargo 项目 # 现在让我们看看使用 Cargo 构建和运行“Hello, world!”程序时有什么不同！在你的 hello_cargo 目录中，通过输入以下命令来构建你的项目：\ncargo build Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs 此命令在 target/debug/hello_cargo（或在 Windows 上为 target\\debug\\hello_cargo.exe）中创建一个可执行文件，而不是在当前目录中。因为默认构建是调试构建，Cargo 将二进制文件放在名为 debug 的目录中。你可以使用以下命令运行可执行文件：\n./target/debug/hello_cargo # 或在 Windows 上为 .\\target\\debug\\hello_cargo.exe Hello, world! 如果一切顺利，Hello, world! 应该会打印到终端。首次运行 cargo build 还会导致 Cargo 在顶层创建一个新文件：Cargo.lock。此文件跟踪项目中依赖项的确切版本\n","externalUrl":null,"permalink":"/zh-cn/rust/01/","section":"Rusts","summary":"\u003ch2 class=\"relative group\"\u003e安装 Rust \n    \u003cdiv id=\"%E5%AE%89%E8%A3%85-rust\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%AE%89%E8%A3%85-rust\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e第一步是安装 Rust。我们将通过 \u003ccode\u003erustup\u003c/code\u003e 下载 Rust，这是一个用于管理 Rust 版本及相关工具的命令行工具。你需要联网才能下载。\u003c/p\u003e","title":"Day1 - Rust 安装与入门指南","type":"rust"},{"content":"在 C 语言中，宏系统是一个强大且灵活的工具，它通过预处理器在编译之前对代码进行文本替换。宏的使用可以简化代码、提高效率，但也可能带来一些潜在问题，如调试困难和可读性下降。本文将带你深入了解 C 语言宏系统的各个方面，并通过丰富的示例展示其用法和应用场景。\n1 宏的基本概念 # 宏是 C 语言预处理器的一部分，它的核心作用是将代码中的特定片段替换为预定义的文本。预处理器指令以 # 开头，并在编译之前处理。\n定义宏 # 宏的定义非常简单，使用 #define 指令即可。例如：\n#define PI 3.14159 #define SQUARE(x) ((x) * (x)) 在代码中，PI 会被替换为 3.14159，而 SQUARE(x) 会被替换为 ((x) * (x))。这种替换发生在编译之前，因此宏的效率非常高。\n宏的分类 # 对象宏：定义常量或文本替换 # 对象宏通常用于定义常量或简单的文本替换。例如：\n#define MAX 100 #define MESSAGE \u0026#34;Hello, World!\u0026#34; 在代码中，MAX 会被替换为 100，而 MESSAGE 会被替换为 \u0026quot;Hello, World!\u0026quot;。\n示例：定义常量\n#include \u0026lt;stdio.h\u0026gt; #define PI 3.14159 #define MAX_VALUE 100 int main() { printf(\u0026#34;PI = %f\\n\u0026#34;, PI); // 输出：PI = 3.141590 printf(\u0026#34;MAX_VALUE = %d\\n\u0026#34;, MAX_VALUE); // 输出：MAX_VALUE = 100 return 0; } 函数宏：带参数的代码片段 # 函数宏类似于函数，但它是通过文本替换实现的。例如：\n#define SQUARE(x) ((x) * (x)) #define MAX(a, b) ((a) \u0026gt; (b) ? (a) : (b)) 示例：计算平方\n#include \u0026lt;stdio.h\u0026gt; #define SQUARE(x) ((x) * (x)) int main() { int a = 5; printf(\u0026#34;Square of %d is %d\\n\u0026#34;, a, SQUARE(a)); // 输出：Square of 5 is 25 return 0; } 注意：宏的陷阱\n宏是文本替换，因此需要小心处理。例如：\n#define SQUARE(x) x * x int result = SQUARE(1 + 2); // 实际替换为 1 + 2 * 1 + 2，结果为 5 而不是 9 为了避免这种问题，通常需要用括号包裹宏的参数和表达式：\n#define SQUARE(x) ((x) * (x)) 带条件的宏：条件编译 # 宏与条件编译指令结合，可以根据特定条件选择性地包含或排除代码片段。例如：\n#define DEBUG #ifdef DEBUG #define LOG(msg) printf(\u0026#34;DEBUG: %s\\n\u0026#34;, msg) #else #define LOG(msg) #endif 示例：调试模式开关\n#include \u0026lt;stdio.h\u0026gt; #define DEBUG #ifdef DEBUG #define LOG(msg) printf(\u0026#34;DEBUG: %s\\n\u0026#34;, msg) #else #define LOG(msg) // 空定义 #endif int main() { LOG(\u0026#34;This is a debug message.\u0026#34;); // 如果定义了DEBUG，则会输出 return 0; } 宏的高级用法 # 字符串化：将宏参数转换为字符串 # 使用 # 操作符可以将宏参数转换为字符串。例如：\n#define STRINGIFY(x) #x printf(STRINGIFY(Hello World)); // 输出 \u0026#34;Hello World\u0026#34; 示例：字符串化\n#include \u0026lt;stdio.h\u0026gt; #define TO_STRING(x) #x int main() { printf(\u0026#34;%s\\n\u0026#34;, TO_STRING(Hello World!)); // 输出：\u0026#34;Hello World!\u0026#34; return 0; } 连接符（##）：拼接标识符 # 使用 ## 操作符可以将两个标记连接成一个标识符。例如：\n#define CONCAT(a, b) a##b int CONCAT(my, Variable) = 10; // 等价于 int myVariable = 10; 示例：标识符拼接\n#include \u0026lt;stdio.h\u0026gt; #define CONCAT(a, b) a##b int main() { int myVariable = 10; printf(\u0026#34;Value: %d\\n\u0026#34;, CONCAT(my, Variable)); // 等价于 myVariable return 0; } 可变参数宏：处理不确定数量的参数 # C99 标准引入了可变参数宏，用于处理参数数量不确定的情况。例如：\n#define LOG(fmt, ...) printf(fmt, __VA_ARGS__) LOG(\u0026#34;Value: %d\\n\u0026#34;, 42); // 等价于 printf(\u0026#34;Value: %d\\n\u0026#34;, 42); 示例：可变参数宏\n#include \u0026lt;stdio.h\u0026gt; #define LOG(fmt, ...) printf(\u0026#34;LOG: \u0026#34; fmt \u0026#34;\\n\u0026#34;, __VA_ARGS__) int main() { LOG(\u0026#34;Value: %d, Name: %s\u0026#34;, 42, \u0026#34;John\u0026#34;); // 输出：LOG: Value: 42, Name: John return 0; } 宏与内联函数的比较 # 宏和内联函数在功能上有一定重叠，但它们各有优缺点：\n特性 宏 内联函数 文本替换 直接文本替换 函数调用 类型检查 无类型检查，可能导致错误 有类型检查，编译期检查参数类型 可读性 大量使用可能降低可读性 更清晰的代码结构 调试 不易调试（无法设置断点） 易于调试（可设置断点） 效率 替换后可能较快，但存在潜在问题 在启用优化时与宏性能相近 宏的优点与缺点 # 优点 # 提高代码重用性：可以用简单的表达式代替复杂的代码。 提高代码可移植性：通过条件编译控制不同平台的代码行为。 提升性能：宏是直接替换，无需函数调用开销。 缺点 # 缺乏类型检查：容易引入潜在的错误。 调试困难：因为是文本替换，调试时无法准确追踪宏。 可读性差：复杂宏会导致代码难以理解。 隐含的副作用：例如不正确的括号处理可能导致意外的逻辑错误。 实际开发中的宏应用 # 简化数组大小获取 # #include \u0026lt;stdio.h\u0026gt; #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0])) int main() { int nums[] = {1, 2, 3, 4, 5}; printf(\u0026#34;Array size: %d\\n\u0026#34;, (int)ARRAY_SIZE(nums)); // 输出：Array size: 5 return 0; } 位操作 # #include \u0026lt;stdio.h\u0026gt; #define SET_BIT(value, bit) ((value) |= (1 \u0026lt;\u0026lt; (bit))) // 设置某个位 #define CLEAR_BIT(value, bit) ((value) \u0026amp;= ~(1 \u0026lt;\u0026lt; (bit))) // 清除某个位 #define TOGGLE_BIT(value, bit) ((value) ^= (1 \u0026lt;\u0026lt; (bit))) // 切换某个位 #define CHECK_BIT(value, bit) ((value) \u0026amp; (1 \u0026lt;\u0026lt; (bit))) // 检查某个位 int main() { int flags = 0; SET_BIT(flags, 1); printf(\u0026#34;Flags after setting bit 1: %d\\n\u0026#34;, flags); // 输出：2 (二进制：10) CLEAR_BIT(flags, 1); printf(\u0026#34;Flags after clearing bit 1: %d\\n\u0026#34;, flags); // 输出：0 return 0; } 防止重复包含头文件 # #ifndef MY_HEADER_H #define MY_HEADER_H // 定义头文件内容 void myFunction(); #endif // MY_HEADER_H 轻量级状态机 # #include \u0026lt;stdio.h\u0026gt; #define STATE_INIT 0 #define STATE_START 1 #define STATE_END 2 #define PROCESS_STATE(state) \\ switch (state) { \\ case STATE_INIT: \\ printf(\u0026#34;Initializing...\\n\u0026#34;); break; \\ case STATE_START: \\ printf(\u0026#34;Starting...\\n\u0026#34;); break; \\ case STATE_END: \\ printf(\u0026#34;Ending...\\n\u0026#34;); break; \\ default: printf(\u0026#34;Unknown state\\n\u0026#34;); break; \\ } int main() { int currentState = STATE_START; PROCESS_STATE(currentState); // 输出：Starting... return 0; } 总结 # 宏是 C 语言中一个强大且灵活的工具，能够显著提升代码的效率和可移植性。然而，它也有一些潜在的缺点，如调试困难和可读性下降。在现代开发中，建议优先使用 const、inline 等更安全和可控的特性，但在某些场景下，宏仍然是一个不可或缺的利器。\n","externalUrl":null,"permalink":"/zh-cn/c/10/","section":"Cs","summary":"\u003cp\u003e在 C 语言中，宏系统是一个强大且灵活的工具，它通过预处理器在编译之前对代码进行文本替换。宏的使用可以简化代码、提高效率，但也可能带来一些潜在问题，如调试困难和可读性下降。本文将带你深入了解 C 语言宏系统的各个方面，并通过丰富的示例展示其用法和应用场景。\u003c/p\u003e","title":"Day10 - 宏","type":"c"},{"content":"在 C 语言中，生成随机数的功能主要通过标准库提供的两个函数来实现：rand() 和 srand()。它们分别用于生成随机数和设置随机数的种子。\nrand() 函数 # rand() 函数用于生成一个伪随机数，它的返回值是一个整型数，范围从 0 到 RAND_MAX。RAND_MAX 是一个常量，表示 rand() 函数可以生成的最大值，其具体数值通常为 32767，但是它的具体值依赖于系统。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { // 生成一个随机数 int num = rand(); printf(\u0026#34;随机数：%d\\n\u0026#34;, num); return 0; } srand() 函数 # 由于 rand() 函数是伪随机的，每次程序运行时生成的随机数序列是相同的。为了使随机数的生成序列不同，可以使用 srand() 函数为随机数生成器设置一个种子。通常，使用系统当前时间（通过 time(NULL)）作为种子来确保每次运行时生成的随机数不同。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { // 设置随机数种子 srand(time(NULL)); // 生成一个随机数 int num = rand(); printf(\u0026#34;随机数：%d\\n\u0026#34;, num); return 0; } 在这段代码中，srand(time(NULL)) 用当前时间设置了种子，使得每次运行程序时生成的随机数都不同。time(NULL) 返回当前的时间戳（秒数），这是一个不断变化的值。\n限制随机数的范围 # rand() 返回的是一个介于 0 和 RAND_MAX 之间的整数。如果你需要限制随机数在一个特定的范围内，可以使用取余运算符 % 或结合加法来调整。\n示例：生成一个范围在 min 到 max 之间的随机数 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { // 设置随机数种子 srand(time(NULL)); // 定义范围 int min = 1; int max = 100; // 生成范围在 [min, max] 之间的随机数 int num = rand() % (max - min + 1) + min; printf(\u0026#34;随机数：%d\\n\u0026#34;, num); return 0; } 在这段代码中，rand() % (max - min + 1) + min 确保了随机数会在 min 到 max 范围内。例如，如果 min = 1 和 max = 100，那么生成的随机数将会是 [1, 100] 之间的一个整数。\n注意事项 # 伪随机性：rand() 生成的随机数是伪随机的，意味着它们并非完全随机，而是通过一定的算法生成的，看起来很随机，但实际上可以通过种子值推算出来。如果需要更高质量的随机数，可以使用更复杂的库，比如 rand_s 或 mt19937 算法（使用 C++ 的 \u0026lt;random\u0026gt; 库）。 RAND_MAX 的值：RAND_MAX 是系统限定的，因此在不同的系统中，rand() 的最大返回值可能不同。一般情况下，RAND_MAX 是一个大约 32767 的常数。 线程安全：rand() 和 srand() 不是线程安全的。如果你需要在多线程环境中生成随机数，建议使用线程安全的库，如 POSIX 的 rand_r() 或者 C11 的 \u0026lt;stdalign.h\u0026gt; 中的 random() 和 srandom() 函数。 使用更高质量的随机数（C11 及以上） # 如果你正在使用 C11 或更高版本的标准，C 标准库提供了更高质量的随机数生成函数：\nrand() 仍然可以使用，但在 C11 之后推荐使用更现代的随机数生成方法。 使用 random() 和 srandom()，它们提供更好的随机性。 总结 # 使用 rand() 生成伪随机数。 使用 srand() 设置随机数的种子，通常结合 time(NULL) 来确保每次程序运行时生成不同的随机数。 使用取余操作调整随机数的范围。 ","externalUrl":null,"permalink":"/zh-cn/c/11/","section":"Cs","summary":"\u003cp\u003e在 C 语言中，生成随机数的功能主要通过标准库提供的两个函数来实现：\u003ccode\u003erand()\u003c/code\u003e 和 \u003ccode\u003esrand()\u003c/code\u003e。它们分别用于生成随机数和设置随机数的种子。\u003c/p\u003e","title":"Day11 - 随机数","type":"c"},{"content":"分支语句在 C 语言中就像是程序的导航系统，告诉代码在不同的条件下该去哪里。这些语句帮助你的程序在不同的情况下选择不同的路线，就像你开车时选择不同的道路以避开交通堵塞。通过这些分支，程序能根据不同的输入或状态选择最合适的代码块，从而提升其灵活性和适应性。\nC 语言中的分支语句有点像你在饭店点餐时的选项：你可以选择“if”你喜欢这道菜，或者“if-else”你更喜欢另一道菜。还有“else-if”结构，就像在菜单上翻找更多的选择，最后是“switch”语句，就像你在自助餐厅里随机挑选自己想吃的美食。本文将以一种轻松愉快的方式，详细介绍这些分支语句的语法、用法以及注意事项，确保你在编程的旅途中不会迷路。 奇怪的比喻增加了\nif 语句 # if 语句是 C 语言中最基础的条件分支控制结构，主要用于判断某个条件是否为真，如果为真则执行特定的代码块。if 语句的条件表达式通常是一个逻辑表达式，其值为 true 或 false。\n语法 # if (条件表达式) { // 条件为真时执行的代码块 } 条件表达式：通常为一个布尔表达式。如果条件成立（即结果为 true），则执行大括号内的代码块；否则跳过该代码块。 代码块：大括号 {} 内的代码仅在条件为真时执行。 举个简单的例子 # #include \u0026lt;stdio.h\u0026gt; int main() { int x = 5; if (x \u0026gt; 0) { printf(\u0026#34;x is positive.\\n\u0026#34;); } return 0; } if (x \u0026gt; 0) 判断变量 x 是否大于 0。因为 x 的值为 5，条件成立，所以会输出 x is positive.。\nif-else 语句 # if-else 语句是 if 语句的扩展，允许程序在条件不成立时执行另一段代码。即当条件为真时执行 if 分支的代码；当条件为假(false)时，执行 else 分支的代码。\n语法格式 # if (条件表达式) { // 条件为真时执行的代码块 } else { // 条件为假时执行的代码块 } 再来个例子 # #include \u0026lt;stdio.h\u0026gt; int main() { int x = -3; if (x \u0026gt; 0) { printf(\u0026#34;x is positive.\\n\u0026#34;); } else { printf(\u0026#34;x is not positive.\\n\u0026#34;); } return 0; } 在这个例子中，变量 x 的值为-3，因此 if (x \u0026gt; 0) 条件不成立，程序会执行 else 分支，输出 x is not positive.。\nelse if 结构 # else if 结构用于处理多个条件判断。它可以在一个 if-else 语句的基础上，增加多个条件判断，直到找到一个为真的条件。如果某个条件成立，则执行该条件对应的代码块，之后的分支将不会执行。\n语法格式 # if (条件表达式 1) { // 条件 1 为真时执行的代码块 } else if (条件表达式 2) { // 条件 2 为真时执行的代码块 } else { // 当所有条件都不成立时执行的代码块 } 还需要一个例子 # #include \u0026lt;stdio.h\u0026gt; int main() { int x = 0; if (x \u0026gt; 0) { printf(\u0026#34;x is positive.\\n\u0026#34;); } else if (x \u0026lt; 0) { printf(\u0026#34;x is negative.\\n\u0026#34;); } else { printf(\u0026#34;x is zero.\\n\u0026#34;); } return 0; } 程序首先判断 x \u0026gt; 0 是否成立，如果成立则执行第一个分支。如果不成立，继续判断 x \u0026lt; 0，如果也不成立，则执行 else 分支。在这个例子中，x 的值为 0，因此会输出 x is zero.。\nswitch 语句 # switch 语句是一种多分支的选择结构，常用于处理离散值的判断。它通过匹配一个表达式的值，执行与该值对应的代码块。switch 语句常用于替代多个 if-else if 的条件判断，使得代码更简洁易读。\n语法格式 # switch (表达式) { case 常量 1: // 当表达式的值等于常量 1 时执行 break; case 常量 2: // 当表达式的值等于常量 2 时执行 break; // 可以有多个 case 分支 default: // 当所有 case 都不匹配时执行 } 表达式：通常是一个整型表达式或字符表达式。 case：用于匹配表达式的值。当表达式的值等于某个 case 分支的常量时，执行该分支的代码。 break：用于跳出 switch 语句。如果不加 break，程序会继续执行下一个 case 的代码（即使条件不匹配），这称为\u0026quot;fall-through\u0026quot;现象。 default：当所有 case 分支都不匹配时，执行 default 分支的代码。 又来一个例子 # #include \u0026lt;stdio.h\u0026gt; int main() { int day = 3; switch (day) { case 1: printf(\u0026#34;Monday\\n\u0026#34;); break; case 2: printf(\u0026#34;Tuesday\\n\u0026#34;); break; case 3: printf(\u0026#34;Wednesday\\n\u0026#34;); break; case 4: printf(\u0026#34;Thursday\\n\u0026#34;); break; case 5: printf(\u0026#34;Friday\\n\u0026#34;); break; default: printf(\u0026#34;Invalid day\\n\u0026#34;); } return 0; } 在这个例子中，day 的值为 3，因此程序会执行 case 3 的代码，输出“Wednesday”。如果没有 break 语句，程序会继续执行下一个 case 的代码，直到遇到 break 或结束 switch 语句。\n嵌套的分支语句 # 分支语句可以互相嵌套，以处理更加复杂的条件判断。常见的嵌套方式是在 if 语句内部嵌套另一个 if 或 switch 语句。\nif 里套 if # #include \u0026lt;stdio.h\u0026gt; int main() { int x = 10; if (x \u0026gt; 0) { if (x % 2 == 0) { printf(\u0026#34;x is positive and even.\\n\u0026#34;); } else { printf(\u0026#34;x is positive and odd.\\n\u0026#34;); } } else { printf(\u0026#34;x is not positive.\\n\u0026#34;); } return 0; } 外层 if 语句判断 x 是否为正数，内层 if 语句进一步判断它的奇偶性。在这个例子中，x 的值为 10，因此会输出 x is positive and even.。\nswitch 里套 switch # #include \u0026lt;stdio.h\u0026gt; int main() { int category = 1; int type = 2; switch (category) { case 1: switch (type) { case 1: printf(\u0026#34;Category 1, Type 1\\n\u0026#34;); break; case 2: printf(\u0026#34;Category 1, Type 2\\n\u0026#34;); break; default: printf(\u0026#34;Unknown type in category 1\\n\u0026#34;); } break; case 2: printf(\u0026#34;Category 2\\n\u0026#34;); break; default: printf(\u0026#34;Unknown category\\n\u0026#34;); } return 0; } 这里我们嵌套了两个 switch 语句，分别处理类别和类别下的类型。category 为 1，type 为 2，因此会输出 Category 1, Type 2。\n注意 # if 语句中的空语句 # 在使用 if 语句时，建议总是使用大括号{}包围代码块，即使代码块中只有一条语句。这可以防止某些情况下由于缩进或其他原因导致的逻辑错误。\n典中典：未使用大括号的潜在问题\n#include \u0026lt;stdio.h\u0026gt; int main() { int x = 5; if (x \u0026gt; 0) printf(\u0026#34;x is positive.\\n\u0026#34;); printf(\u0026#34;This is outside the if.\\n\u0026#34;); // 实际上总是会执行 return 0; } x is positive. This is outside the if. 由于没有使用大括号，第二个 printf 语句并不属于 if 语句的条件判断部分。它将始终执行，可能导致不符合预期的程序行为。\n改进示例\n#include \u0026lt;stdio.h\u0026gt; int main() { int x = 5; if (x \u0026gt; 0) { printf(\u0026#34;x is positive.\\n\u0026#34;); printf(\u0026#34;This is inside the if.\\n\u0026#34;); // 只有条件成立时才执行 } return 0; } x is positive. This is inside the if.\nswitch 语句中的“fall-through”现象 # switch 语句中，如果没有 break 语句，会发生“fall-through”现象，导致程序继续执行下一个 case 的代码块，即使表达式不匹配下一个 case。\n#include \u0026lt;stdio.h\u0026gt; int main() { int x = 2; switch (x) { case 1: printf(\u0026#34;One\\n\u0026#34;); case 2: printf(\u0026#34;Two\\n\u0026#34;); // 执行此 case 后会继续执行 case 3 的代码 case 3: printf(\u0026#34;Three\\n\u0026#34;); break; default: printf(\u0026#34;Unknown\\n\u0026#34;); } return 0; } Two Three 改进示例\n#include \u0026lt;stdio.h\u0026gt; int main() { int x = 2; switch (x) { case 1: printf(\u0026#34;One\\n\u0026#34;); break; case 2: printf(\u0026#34;Two\\n\u0026#34;); break; case 3: printf(\u0026#34;Three\\n\u0026#34;); break; default: printf(\u0026#34;Unknown\\n\u0026#34;); } return 0; } Two 来一点高级技巧 # 使用三元运算符简化条件判断 # C 语言提供了三元运算符?:，用于简化简单的条件判断。三元运算符的语法如下：\n条件 ? 表达式 1 : 表达式 2; 当条件为真时，返回表达式 1 的值；否则返回表达式 2 的值。它通常用于替代简单的 if-else 结构。\n#include \u0026lt;stdio.h\u0026gt; int main() { int x = 5; const char result = (x \u0026gt; 0) ? \u0026#34;positive\u0026#34; : \u0026#34;non-positive\u0026#34;; printf(\u0026#34;x is %s.\\n\u0026#34;, result); return 0; } 枚举与 switch 语句的结合 # 当处理一组相关的常量时，可以使用 enum 枚举类型结合 switch 语句，这样代码更加清晰，并减少了使用魔术数字的风险。 示例：使用枚举和 switch\n#include \u0026lt;stdio.h\u0026gt; enum Days { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY }; int main() { enum Days today = WEDNESDAY; switch (today) { case MONDAY: printf(\u0026#34;Today is Monday.\\n\u0026#34;); break; case TUESDAY: printf(\u0026#34;Today is Tuesday.\\n\u0026#34;); break; case WEDNESDAY: printf(\u0026#34;Today is Wednesday.\\n\u0026#34;); break; case THURSDAY: printf(\u0026#34;Today is Thursday.\\n\u0026#34;); break; case FRIDAY: printf(\u0026#34;Today is Friday.\\n\u0026#34;); break; default: printf(\u0026#34;Unknown day.\\n\u0026#34;); } return 0; } 总结 # 通过合理使用分支语句，程序可以根据输入和条件灵活调整执行路径，完成更为复杂的任务。在编写代码时，牢记代码的可读性和可维护性，尽量简化逻辑和控制流。\n生命中最重要的不是我们选择了什么，而是我们如何对待我们所选择的\n","externalUrl":null,"permalink":"/zh-cn/c/02/","section":"Cs","summary":"\u003cp\u003e分支语句在 C 语言中就像是程序的导航系统，告诉代码在不同的条件下该去哪里。这些语句帮助你的程序在不同的情况下选择不同的路线，就像你开车时选择不同的道路以避开交通堵塞。通过这些分支，程序能根据不同的输入或状态选择最合适的代码块，从而提升其灵活性和适应性。\u003c/p\u003e","title":"Day2 - 不一样的选择却殊途同归","type":"c"},{"content":"今天的内容将为你提供一个清晰的起点，帮助你掌握循环语句这一编程中的重要概念。循环语句让我们能够高效地重复执行任务，这不仅是编程的基本能力之一，更是编写灵活、动态程序的关键。 准备好了吗？让我们一起进入 C 语言的世界，揭开循环语句的神秘面纱，开始这场充满逻辑与创造力的冒险吧！C 语言，启动！\nfor 循环 # for 循环是最常见的循环之一。最经典形状应该是长下面这样的：\nfor (初始化; 条件; 更新) { // 循环体 } 具体的执行步骤 # 初始化：在循环开始时执行一次。 条件：每次循环前检查，如果条件为真（非零），继续执行循环体；为假（零）则退出循环。 更新：每次循环结束后执行一次，通常用于更新循环变量。 举个栗子 # #include \u0026lt;stdio.h\u0026gt; int main() { int i; for (i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;i = %d\\n\u0026#34;, i); } return 0; } 这个例子中，i 从 0 开始，每次循环加 1，直到 i 不小于 5。输出结果是 i = 0 到 i = 4。\n注意点 # for 循环适用于已知循环次数的情况。你可以在 for 循环中省略某些部分，比如初始化或更新，但分号必须保留。\n特殊的 for(;;) # for (;;) 是一种特殊的 for 循环结构，它表示一个无限循环。\n具体剖析 # 按照刚才对 for 结构的分析，我们不难发现，在 for (;;) 中，三个部分都被省略了：\n初始化：没有初始化变量。 条件：没有明确条件，C/C++ 默认为真（true），因此会导致无限循环。 迭代：没有迭代语句。 由于没有条件限制，所以当遇到 for (;;) 时，程序会无限地执行其循环体，直到发生某种中断，如 break、return 或外部干预（例如终止程序）\n来个栗子 # #include \u0026lt;stdio.h\u0026gt; int main() { int count = 0; for (;;) { // 无限循环 printf(\u0026#34;Count: %d\\n\u0026#34;, count); count++; if (count \u0026gt;= 5) { break; // 当 count 达到 5 时退出循环 } } return 0; } while 循环 # while 循环是在条件为真时反复执行的循环。\nwhile (条件) { // 循环体 } 在每次循环前检查。如果条件为真（非零），执行循环体；否则退出循环。\n还是需要一个例子 # #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; while (i \u0026lt; 5) { printf(\u0026#34;i = %d\\n\u0026#34;, i); i++; } return 0; } 这个例子与 for 循环的例子类似，i 从 0 开始，每次循环加 1，直到 i 不小于 5 时退出。\n注意点 # 如果条件在循环内没有被修改，可能导致死循环（循环永远不会结束）。但是有的时候我们也会主动创造一些死循环的情况，比如说像下面这种，条件始终为真，那么如果内部不退出或者杀死进程的话，会不停运行循环体。\nwhile (true) { // 循环体 } do-while 循环 # do-while 循环与 while 循环类似，但它至少执行一次循环体，然后再检查条件。\ndo { // 循环体 } while (条件); 首先执行一次循环体，然后检查条件。如果条件为真，继续循环；否则退出。\nExample # #include \u0026lt;stdio.h\u0026gt; int main() { int i = 0; do { printf(\u0026#34;i = %d\\n\u0026#34;, i); i++; } while (i \u0026lt; 5); return 0; } 这里 i 依旧从 0 开始，循环体会先执行一次，然后再检查条件。\n注意点 # 由于 do-while 循环是先执行再判断条件，因此即使条件一开始为假，循环体也会执行一次。\n经典循环应用 # 求和算法 # 计算从 1 到 100 的所有整数之和。\n#include \u0026lt;stdio.h\u0026gt; int main() { int sum = 0; int i; for (i = 1; i \u0026lt;= 100; i++) { sum += i; } printf(\u0026#34;1到100的和是: %d\\n\u0026#34;, sum); return 0; } 计算阶乘 # 计算一个数的阶乘，比如 5! = 5 × 4 × 3 × 2 × 1。\n#include \u0026lt;stdio.h\u0026gt; int main() { int n = 5; // 要计算的阶乘数 int factorial = 1; int i; for (i = 1; i \u0026lt;= n; i++) { factorial *= i; } printf(\u0026#34;%d 的阶乘是: %d\\n\u0026#34;, n, factorial); return 0; } 斐波那契数列 # 生成斐波那契数列的前 10 个数字。\n#include \u0026lt;stdio.h\u0026gt; int main() { int n = 10; int first = 0, second = 1, next; int i; printf(\u0026#34;斐波那契数列: \u0026#34;); for (i = 0; i \u0026lt; n; i++) { if (i \u0026lt;= 1) { next = i; } else { next = first + second; first = second; second = next; } printf(\u0026#34;%d \u0026#34;, next); } printf(\u0026#34;\\n\u0026#34;); return 0; } 总结 # for 循环：适用于已知循环次数的情况。 while 循环：适用于条件驱动的循环。 do-while 循环：至少执行一次的条件循环。 人生就像一场旅行，不要重复走以前的路，而要勇敢地探索未知的方向。\n","externalUrl":null,"permalink":"/zh-cn/c/03/","section":"Cs","summary":"\u003cp\u003e今天的内容将为你提供一个清晰的起点，帮助你掌握循环语句这一编程中的重要概念。循环语句让我们能够高效地重复执行任务，这不仅是编程的基本能力之一，更是编写灵活、动态程序的关键。\n准备好了吗？让我们一起进入 C 语言的世界，揭开循环语句的神秘面纱，开始这场充满逻辑与创造力的冒险吧！\u003cstrong\u003eC 语言，启动！\u003c/strong\u003e\u003c/p\u003e","title":"Day3 - 重复的事情说一次就够了","type":"c"},{"content":" 引入 # 学习 C 语言时，理解类型系统和类型转换是非常重要的。它们帮助你掌握如何存储和操作不同类型的数据。在接下来的讲解中，我会以简单生动的方式带你一探 C 语言类型系统的奥秘，并通过示例加深理解。\n类型系统 # C 语言是一门强类型语言，这意味着每一个变量在使用之前都必须有一个确定的类型。数据类型决定了变量可以存储什么样的数据，以及在内存中占据多少空间。\n基本数据类型 # 整型（Integer Types） # int：标准整型，通常占用 4 字节内存。 short：短整型，通常占用 2 字节。 long：长整型，通常占用 4 或 8 字节。 long long：更长的整型，通常占用 8 字节。 int age = 25; short year = 2022; long population = 8000000L; long long distance = 12345678901234LL; 字符型（Character Type） # char：用于存储单个字符，占用 1 字节内存。\nchar letter = \u0026#39;A\u0026#39;; 浮点型（Floating Point Types） # float：单精度浮点型，通常占用 4 字节内存。 double：双精度浮点型，通常占用 8 字节内存。 long double：扩展精度浮点型，通常占用 12 或 16 字节。 float pi = 3.14f; double e = 2.718281828459045; 枚举类型（Enumerated Types） # 枚举类型是一种用户定义的类型，用于定义一组命名的整型常量。主要是为了更好的描述数据，并简化代码。\nenum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY }; enum Day today = WEDNESDAY; void 类型 # void 类型表示“无类型”，通常用于函数返回类型表示该函数不返回任何值。注意：部分教程说函数返回值 void 可以省略并不是好习惯！\nvoid sayHello() { printf(\u0026#34;Hello, World!\\n\u0026#34;); } 指针类型 # 指针是 C 语言中的重要类型，用于存储内存地址，也是 c 语言入门学习的噩梦之一。指针的类型决定了它指向的变量类型。\nint x = 10; int *ptr = \u0026amp;x; // ptr 是一个指向整数的指针，存储 x 的地址 类型转换 # 在 C 语言中，有时候需要将一种类型的数据转换为另一种类型的数据。类型转换可以分为隐式类型转换和显式类型转换。\n隐式类型转换 # 当你在表达式中混合使用不同类型的变量时，编译器会自动将它们转换为相同的类型，以避免数据损失。这种转换称为隐式类型转换。说白了就是编译器帮你自动添加了一些代码，完成了这个任务，不需要你来操心！\nint a = 5; double b = 3.2; double result = a + b; // a 被隐式转换为 double 类型 但是需要注意的是，并不是所有同类类型都可以隐式转换！编译器通常会将“窄”类型（如 int）转换为“宽”类型（如 double），以确保精度。\n显式类型转换（强制类型转换） # 有时候，常规的隐式转换已经不能满足需求，你需要手动将一种类型的数据转换为另一种类型，这被称为显式类型转换。具体的语法形式为：\nnew_type variable = (new_type)expression; double pi = 3.14159; int truncated_pi = (int)pi; // 将 double 转换为 int，结果为3 这时候你可能发现了，pi 的小数部分被抹去了，因此强制转换可能会导致数据丢失，所以使用强制转换时要小心，确保了解数据的潜在变化。\n来点例子 # 整数到浮点数的转换 #include \u0026lt;stdio.h\u0026gt; int main() { int apples = 10; double price = 1.5; double total_cost = apples * price; // 隐式类型转换，apples 被转换为 double printf(\u0026#34;Total cost: $%.2f\\n\u0026#34;, total_cost); return 0; } 在这个例子中，apples 是一个整型，price 是一个浮点型。在计算total_cost时，apples 被隐式转换为 double 类型以进行浮点数乘法运算。\n强制类型转换 #include \u0026lt;stdio.h\u0026gt; int main() { double average = 85.6; int rounded_average = (int)average; // 强制转换为 int，结果为 85 printf(\u0026#34;Rounded average: %d\\n\u0026#34;, rounded_average); return 0; } average 是一个double类型。在将其转换为int时，强制转换 截断了小数部分 ，使得rounded_average变为 85。\n指针类型转换 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 42; void *ptr = \u0026amp;a; // 将 int 指针转换为 void 指针 int *int_ptr = (int *)ptr; // 强制转换回 int 指针 printf(\u0026#34;Value of a: %d\\n\u0026#34;, *int_ptr); return 0; } 这里，ptr 原本是一个void指针，可以指向任何类型的变量。我们将它强制转换回 int 指针，以正确地访问变量 a 的值。\n陷阱和注意点 # 溢出问题：在类型转换时，特别是从大类型转换为小类型时，要注意溢出问题。例如，将一个 long 值强制转换为 short 时，如果 long 值超出了 short 的范围，可能会得到一个错误的结果。 long big_number = 1234567890L; short small_number = (short)big_number; // 可能导致溢出，结果不可预测 截断问题：当从浮点类型转换为整数类型时，小数部分会被截断。要确保这种截断是你想要的结果。 double pi = 3.14159; int truncated_pi = (int)pi; // 结果为 3，截断了小数部分 指针类型的转换：指针的类型转换需要特别小心。如果你将一个指向某种类型的指针转换为另一种类型的指针，可能会导致未定义行为。 int a = 10; double *ptr = (double *)\u0026amp;a; // 可能导致指针错误访问 数组 # 刚刚我们讲解的都是单个变量，那么如果我要存储一组类型相同的变量，难道只能够定义 n 个变量吗？显然不用，这个时候就要请出数组了！\n数组是 C 语言中一个非常重要的概念，它让我们可以处理一组相同类型的数据。数组在内存中是连续存储的，可以高效地管理和访问大量数据。\n一维数组 # 定义和初始化 # 一维数组是最基本的数组类型，存储一组相同类型的数据。\nint arr[5]; // 定义一个包含5个整型元素的数组，中括号内的数字即为数组大小 你可以在定义数组时进行初始化：\nint arr[5] = {1, 2, 3, 4, 5}; // 初始化一个包含5个元素的数组 如果你不指定数组的大小，编译器会根据初始化列表自动推导大小：\nint arr[] = {1, 2, 3}; // 自动推导数组大小为3 需要注意的是，如果你部分初始化数组，那么未初始化的元素会被设置为 0。\nint arr[5] = {1, 2}; // 剩余元素自动初始化为0 访问元素 # 这里很明确，我们可以通过数组的索引来访问和修改元素。这里有一个大坑， 索引从 0 开始 ，初学者往往会习惯性认为索引从 1 开始而导致错误。\nint x = arr[2]; // 获取数组的第三个元素，值为3 arr[0] = 10; // 将第一个元素的值改为10 多维数组 # 多维数组用于存储表格或矩阵形式的数据。其中，二维数组是最常见的多维数组。\n定义\u0026amp;初始化 # 二维数组可以看作是“数组的数组”，即每个元素本身又是一个数组。来个简单的例子：\nint matrix[3][4]; // 定义一个3行4列的二维数组 同理，二维数组的初始化可以通过嵌套的花括号来完成：\nint matrix[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }; 当然，如果你不明确行列也是可以的，编译器会自动处理行和列的关联，就像下面这样：\nint matrix[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; 访问 # 由访问一维数组需要一个索引可以推断，访问二维数组的元素需要两个索引，分别表示行和列。\nint value = matrix[1][2]; // 获取第二行第三列的值，值为7 matrix[2][3] = 15; // 将第三行第四列的值设为15 多维数组的元素在内存中是连续存储的，行优先（row-major） 顺序。即第一行的所有元素存储在内存中，然后是第二行，依此类推。\n指针数组和数组指针 # 指针数组 # 指针数组是一个数组，其中的每个元素都是指针。它通常用于存储字符串数组或其他需要动态分配内存的数据。\nchar *strArr[3]; // 定义一个字符指针数组 strArr[0] = \u0026#34;Hello\u0026#34;; strArr[1] = \u0026#34;World\u0026#34;; strArr[2] = \u0026#34;C\u0026#34;; 你可以通过数组索引访问这些字符串：\nprintf(\u0026#34;%s\\n\u0026#34;, strArr[1]); // 输出 \u0026#34;World\u0026#34; 数组指针 # 数组指针是指向数组的指针。它允许我们通过指针操作数组。\nint arr[5] = {1, 2, 3, 4, 5}; int (*p)[5] = \u0026amp;arr; // p 是一个指向包含5个整数的数组的指针 你可以通过指针访问数组元素：\nint x = (*p)[2]; // 获取第三个元素，值为3 指针运算 # 由于数组名实际上是指向数组首元素的指针，因此可以进行指针运算：\nint arr[5] = {1, 2, 3, 4, 5}; int *p = arr; printf(\u0026#34;%d\\n\u0026#34;, *(p + 2)); // 输出3，即arr[2] p + 2 表示指针 p 向后移动两个元素，然后通过*解引用访问该元素的值。\n二级数组（指针的数组） # 二级数组通常用于表示指针的数组，特别是在处理二维数组或指针数组时。\n定义 and 用法 # 一个简单的二级数组是一个指向指针的指针（char **或 int **）。这种结构可以用于 动态分配 二维数组或处理字符指针数组。\nchar *lines[] = {\u0026#34;line1\u0026#34;, \u0026#34;line2\u0026#34;, \u0026#34;line3\u0026#34;}; char **p = lines; // p 是一个指向字符指针的指针 你可以使用二级指针访问或修改指针数组的内容：\nprintf(\u0026#34;%s\\n\u0026#34;, p[1]); // 输出 \u0026#34;line2\u0026#34; p[2] = \u0026#34;new line3\u0026#34;; // 修改第三个指针所指向的字符串 动态分配 # 二级指针非常适合动态分配二维数组，下面是一个典型例子：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int rows = 3; // 矩阵的行数 int cols = 4; // 矩阵的列数 // 动态分配一个指向指针的数组，用于存储每一行的指针 int **matrix = (int **)malloc(rows * sizeof(int *)); // 为每一行动态分配列数的内存 for (int i = 0; i \u0026lt; rows; i++) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化矩阵 for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { matrix[i][j] = i * cols + j; // 将矩阵元素赋值为它的线性索引 } } // 打印矩阵 printf(\u0026#34;矩阵内容：\\n\u0026#34;); for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { printf(\u0026#34;%d \u0026#34;, matrix[i][j]); // 打印每个元素 } printf(\u0026#34;\\n\u0026#34;); // 换行 } // 释放内存 for (int i = 0; i \u0026lt; rows; i++) { free(matrix[i]); // 释放每一行的内存 } free(matrix); // 释放存储行指针的数组 return 0; // 返回成功状态 } 0 1 2 3 4 5 6 7 8 9 10 11 柔性数组（Flexible Array Members） # 柔性数组成员是一种 C99 标准引入的高级特性，允许在结构体中定义一个可变长度的数组。这种数组没有固定的大小，需要通过动态内存分配来使用。\n定义\u0026amp;使用 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct FlexibleArray { int length; int array[]; // 柔性数组成员 }; int main() { int n = 5; // 动态分配内存，包含结构体和数组的总大小 struct FlexibleArray *fa = malloc(sizeof(struct FlexibleArray) + n * sizeof(int)); fa-\u0026gt;length = n; for (int i = 0; i \u0026lt; n; i++) { fa-\u0026gt;array[i] = i * 2; // 初始化数组 } // 打印数组 for (int i = 0; i \u0026lt; fa-\u0026gt;length; i++) { printf(\u0026#34;%d \u0026#34;, fa-\u0026gt;array[i]); } printf(\u0026#34;\\n\u0026#34;); free(fa); // 释放内存 return 0; } 0 2 4 6 8 需要格外注意的是，柔性数组成员 array[]在定义时不指定大小，内存分配时根据需要来决定数组的实际大小！\n静态数组和动态数组 # 其实，上面的很多例子中已经出现了这两个概念，那么下面就是具体的讲解。\n静态数组 # 静态数组是在 编译时 分配内存的，数组的大小在程序编译时就已经确定，并且在程序的生命周期内保持不变。静态数组通常分配在栈内存中，大小是 固定的。\nint static_array[10]; // 定义一个大小为10的静态数组 优点：\n访问速度快，因为它们位于栈内存中。 不需要手动管理内存，编译器会自动处理内存的分配和释放。 缺点：\n大小固定，一旦定义，无法在程序运行时更改。 如果数组很大，可能导致栈溢出，特别是在嵌套调用较深的情况下。 动态数组 # 动态数组是在程序运行时根据需要动态分配内存的。它的大小可以在运行时确定，并且可以在程序的不同阶段分配和释放内存。动态数组通常分配在堆内存中。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int n = 10; int *dynamic_array = (int *)malloc(n * sizeof(int)); // 动态分配一个大小为n的数组 if (dynamic_array == NULL) { printf(\u0026#34;Memory allocation failed!\\n\u0026#34;); return 1; } // 使用数组 for (int i = 0; i \u0026lt; n; i++) { dynamic_array[i] = i * 2; } // 打印数组 for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, dynamic_array[i]); } printf(\u0026#34;\\n\u0026#34;); // 释放内存 free(dynamic_array); return 0; } 优点：\n数组的大小可以在运行时动态调整。 适合处理需要在运行时确定大小的大型数据集。 缺点：\n需要手动管理内存，必须确保在使用完后释放内存（使用 free 函数），否则会导致内存泄漏。 动态内存分配相比静态内存分配速度稍慢，因为它涉及到系统调用。 函数中的数组参数 # 当数组作为参数传递给函数时，它实际上是将数组的指针传递给函数。因此，函数内对数组的任何修改会影响到原数组。\nvoid modifyArray(int *arr, int size) { for (int i = 0; i \u0026lt; size; i++) { arr[i] = arr[i] * 2; } } int main() { int arr[5] = {1, 2, 3, 4, 5}; modifyArray(arr, 5); for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); // 输出2 4 6 8 10 } return 0; } 复杂一点的特性 # 动态调整数组大小：realloc # 动态数组的大小可以在运行时通过 realloc函数调整。这允许你在程序运行期间根据需要扩展或缩小数组的大小。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int *arr = (int *)malloc(5 * sizeof(int)); for (int i = 0; i \u0026lt; 5; i++) { arr[i] = i; } // 调整数组大小 arr = (int *)realloc(arr, 10 * sizeof(int)); for (int i = 5; i \u0026lt; 10; i++) { arr[i] = i * 2; } // 打印数组 for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } printf(\u0026#34;\\n\u0026#34;); free(arr); return 0; } 需要注意，realloc 可能会移动数组到新的内存位置，因此返回的指针可能不同于原来的指针。如果 realloc 失败，返回 NULL，旧的内存保持不变。\n数组中的注意点 # 数组越界 数组越界是 C 语言中常见且危险的错误，访问数组边界之外的内存可能导致未定义行为或程序崩溃。通常情况下你会获得名为 Segmentation Fault 的错误，也就是臭名昭著的段错误!\nint arr[5] = {1, 2, 3, 4, 5}; int value = arr[5]; // 错误：越界访问，而且是由最容易犯得记错索引导致的 指针和数组的关系 数组名在大多数表达式中会被转换为指向其第一个元素的指针。例如：\nint arr[5] = {1, 2, 3, 4, 5}; int *p = arr; // p 指向 arr[0] 但是，数组名并不是指针，它是一个常量指针，不能被修改。\n字符串 # 很多时候我们需要让变量能够存储一个句子，那么就需要用到字符串了。C 语言中的字符串体系是一个非常重要的概念，因为它涉及到如何存储、处理和操作文本数据。在 C 语言中，字符串并不像在其他高级语言中那样是一个独立的数据类型，而是一个字符数组。\n表示字符串 # 在 C 语言中，字符串是由字符数组表示的，且以 空字符（\\0） 结尾。空字符标志着字符串的结束， 因此它的长度比实际字符数多一位。\n定义与初始化 # char str1[] = \u0026#34;Hello, World!\u0026#34;; 这里我们并没有添加\\0，但是仍然是正确的，因为编译器会自动添加\\0，因此 str1 的实际大小是 14 个字符（包括\\0）。这种初始化方式是最常用的，也是最安全的，因为它 自动处理了字符串的结束标志。\n当然了，如果你不嫌麻烦，也可以逐字符初始化一个字符串，虽然这有点呆：\nchar str2[] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; 不过这种方式也更灵活，但方便与灵活不可兼得，这样容易出错，尤其是在手动忘记添加\\0 时，当场爆炸。\n你还可以定义一个指向字符串的指针：\nchar *str3 = \u0026#34;Hello, World!\u0026#34;; 这里 str3 是一个指向字符串常量的指针。需要注意的是，这种方式定义的字符串通常存储在只读内存区，因此不能修改它的内容，可以加上 const 修饰符表明这是一个常量。\n常见操作 # C 语言标准库提供了一组函数来处理字符串。这些函数大多在\u0026lt;string.h\u0026gt;头文件中定义。需要注意的是，c 语言提供的很多操作函数其实是不安全的，在\nstrlen：获取字符串长度 # `strlen 用于获取字符串的长度 （不包括末尾的\\0）。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;Hello, World!\u0026#34;; int length = strlen(str); printf(\u0026#34;Length of the string: %d\\n\u0026#34;, length); return 0; } Length of the string: 13 strcpy：复制字符串 # strcpy 函数将一个字符串复制到另一个字符串中。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char src[] = \u0026#34;Hello\u0026#34;; char dest[20]; // 确保目标数组足够大，不然会溢出 strcpy(dest, src); printf(\u0026#34;Copied string: %s\\n\u0026#34;, dest); return 0; } Copied string: Hello strcat：连接字符串 # strcat 函数将两个字符串连接在一起。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char str1[20] = \u0026#34;Hello\u0026#34;; char str2[] = \u0026#34;, World!\u0026#34;; strcat(str1, str2); // 确保目标数组有足够的空间存储连接后的字符串，包括空字符\\0。 printf(\u0026#34;Concatenated string: %s\\n\u0026#34;, str1); return 0; } Concatenated string: Hello, World! strcmp：比较字符串 # strcmp 函数用于比较两个字符串的字典顺序。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char str1[] = \u0026#34;Apple\u0026#34;; char str2[] = \u0026#34;Banana\u0026#34;; int result = strcmp(str1, str2); if (result \u0026lt; 0) { printf(\u0026#34;str1 is less than str2\\n\u0026#34;); } else if (result \u0026gt; 0) { printf(\u0026#34;str1 is greater than str2\\n\u0026#34;); } else { printf(\u0026#34;str1 is equal to str2\\n\u0026#34;); } return 0; } str1 is less than str2 strcmp 返回一个整数值，如果第一个字符串在字典顺序上小于、等于或大于第二个字符串，则分别返回负值、0 或正值。\nstrchr 和 strstr：查找字符或子串 # strchr 用于查找字符串中某个字符的第一次出现。 strstr 用于查找一个字符串中第一次出现的子串。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026#34;Hello, World!\u0026#34;; char *pos = strchr(str, \u0026#39;W\u0026#39;); if (pos != NULL) { printf(\u0026#34;Character found at position: %ld\\n\u0026#34;, pos - str); } else { printf(\u0026#34;Character not found.\\n\u0026#34;); } char *substr = strstr(str, \u0026#34;World\u0026#34;); if (substr != NULL) { printf(\u0026#34;Substring found: %s\\n\u0026#34;, substr); } else { printf(\u0026#34;Substring not found.\\n\u0026#34;); } return 0; } Character found at position: 7 Substring found: World! 字符串操作中的注意点 # 很多前面都有，但还是反复强调！\n字符数组大小 # 在定义字符数组时，一定要确保数组大小足够容纳字符串和空字符\\0。例如：\nchar str[5] = \u0026#34;Hello\u0026#34;; // 错误：数组长度不足 这个例子会导致缓冲区溢出，因为\u0026quot;Hello\u0026quot;需要 6 个字符空间（包括\\0）。\n字符串常量和可变性 # 字符串常量（例如\u0026quot;Hello\u0026quot;）通常存储在只读内存中，因此不能通过指针修改它们。如果你尝试修改一个字符串常量，会导致运行时错误：\nchar *str = \u0026#34;Hello\u0026#34;; str[0] = \u0026#39;h\u0026#39;; // 错误：可能导致程序崩溃 缓冲区溢出 # 字符串操作时的缓冲区溢出是 C 语言中非常常见且危险的错误。操作字符串时务必确保目标缓冲区的大小足够。例如：\nchar str1[10] = \u0026#34;Hello\u0026#34;; char str2[] = \u0026#34;World!\u0026#34;; strcat(str1, str2); // 错误：str1 缓冲区溢出 这种错误会导致未定义行为，甚至程序崩溃。\n来几个经典的例子 # 反转字符串 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void reverse(char str[]) { int n = strlen(str); for (int i = 0; i \u0026lt; n / 2; i++) { char temp = str[i]; str[i] = str[n - i - 1]; str[n - i - 1] = temp; } } int main() { char str[] = \u0026#34;Hello, World!\u0026#34;; reverse(str); printf(\u0026#34;Reversed string: %s\\n\u0026#34;, str); return 0; } Reversed string: !dlroW ,olleH 检查回文字符串 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int isPalindrome(char str[]) { int n = strlen(str); for (int i = 0; i \u0026lt; n / 2; i++) { if (str[i] != str[n - i - 1]) { return 0; } } return 1; } int main() { char str[] = \u0026#34;madam\u0026#34;; if (isPalindrome(str)) { printf(\u0026#34;The string is a palindrome.\\n\u0026#34;); } else { printf(\u0026#34;The string is not a palindrome.\\n\u0026#34;); } return 0; } The string is a palindrome. 总结 # 今天的内容很多，需要好好消化，希望你能够理解并应用到你的实际编程项目中。\n人生是一条不断探索的旅程，充满了选择与变化，体验着喜悦与挑战，最终形成我们独特的故事。\n","externalUrl":null,"permalink":"/zh-cn/c/04/","section":"Cs","summary":"\u003ch2 class=\"relative group\"\u003e引入 \n    \u003cdiv id=\"%E5%BC%95%E5%85%A5\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%BC%95%E5%85%A5\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e学习 C 语言时，理解类型系统和类型转换是非常重要的。它们帮助你掌握如何存储和操作不同类型的数据。在接下来的讲解中，我会以简单生动的方式带你一探 C 语言类型系统的奥秘，并通过示例加深理解。\u003c/p\u003e","title":"Day4 - 你是个什么东西","type":"c"},{"content":" 引入 # 在 C 语言中，输入是从用户或文件等外部源获取数据并存储到程序变量中的过程。C 语言提供了多种方式来获取输入数据，包括标准输入函数、文件输入函数以及低级别的系统输入函数。\n标准输入函数 # scanf # scanf是 C 语言中最常用的标准输入函数，它允许从标准输入（通常是键盘）中读取格式化的数据，并将这些数据存储到变量中。\nint scanf(const char *format, ...); format：指定要读取的输入数据类型的格式字符串（例如\u0026quot;%d\u0026quot;表示整数，\u0026quot;%f\u0026quot;表示浮点数）。 返回值：返回成功读取的变量数量。如果读取失败，返回值为 EOF。 举个例子：\n#include \u0026lt;stdio.h\u0026gt; int main() { int num; float f; printf(\u0026#34;Enter an integer and a float: \u0026#34;); scanf(\u0026#34;%d %f\u0026#34;, \u0026amp;num, \u0026amp;f); printf(\u0026#34;You entered: %d and %.2f\\n\u0026#34;, num, f); return 0; } 需要注意的是：\nscanf 需要传入变量的地址（使用\u0026amp;符号），因为它需要修改这些变量的值。 scanf 会忽略输入数据中的空格、换行符和制表符，但可以用空格等分隔符来读取多项数据。 如果输入的格式与指定的格式不匹配，可能导致读取失败或数据错误。 fscanf # fscanf 与 scanf 类似，但它是从文件流中读取格式化数据。\nint fscanf(FILE *stream, const char *format, ...); stream：文件流指针，指定要读取数据的文件。 其他参数与 scanf 相同。 来个基础示例\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE *file = fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening file!\\n\u0026#34;); return 1; } int num; fscanf(file, \u0026#34;%d\u0026#34;, \u0026amp;num); printf(\u0026#34;Number from file: %d\\n\u0026#34;, num); fclose(file); return 0; } 切记，使用 fscanf 时，确保文件已成功打开，并在使用完毕后 正确关闭文件。\nsscanf # 从名字可以看出，sscanf 从字符串中读取格式化数据，而不是从标准输入或文件。\nint sscanf(const char *str, const char *format, ...); str：要读取数据的字符串。 其他参数与 scanf 相同。 #include \u0026lt;stdio.h\u0026gt; int main() { char input[] = \u0026#34;42 3.14\u0026#34;; int num; float f; sscanf(input, \u0026#34;%d %f\u0026#34;, \u0026amp;num, \u0026amp;f); printf(\u0026#34;Parsed values: %d and %.2f\\n\u0026#34;, num, f); return 0; } 字符输入函数 # getchar # getchar 从标准输入中读取一个字符。它是一个简单的字符输入函数，通常用于逐字符读取输入。\nint getchar(void); 返回值：返回读取的字符（作为 int 类型）。如果遇到输入结束（EOF），返回 EOF。 #include \u0026lt;stdio.h\u0026gt; int main() { char c; printf(\u0026#34;Enter a character: \u0026#34;); c = getchar(); printf(\u0026#34;You entered: %c\\n\u0026#34;, c); return 0; } 需要格外注意的是，getchar 不会跳过空格和换行符，它会逐字符读取每一个输入字符。由于返回值为 int，你需要将其转换为 char 类型来使用。\nfgetc # fgetc 与 getchar 类似，但它用于从文件中读取一个字符。\nint fgetc(FILE *stream); stream：要从中读取字符的文件流指针。 返回值：返回读取的字符（作为 int 类型）。如果遇到文件结束或错误，返回 EOF。 #include \u0026lt;stdio.h\u0026gt; int main() { FILE *file = fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening file!\\n\u0026#34;); return 1; } char c; while ((c = fgetc(file)) != EOF) { putchar(c); // 打印读取的字符 } fclose(file); return 0; } 注意点：\nfgetc 用于从文件流中逐字符读取数据，适用于处理文件内容的逐行或逐字符处理。 读取时会自动移动文件指针，逐字符读取下一个字符。 getc # getc 与 fgetc 功能相同，但可能实现方式略有不同。getc 通常用于从文件流中读取字符。\nint getc(FILE *stream); stream：文件流指针。 返回值：返回读取的字符（作为 int 类型），或在遇到 EOF 时返回 EOF。 #include \u0026lt;stdio.h\u0026gt; int main() { FILE *file = fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening file!\\n\u0026#34;); return 1; } char c; while ((c = getc(file)) != EOF) { putchar(c); // 打印读取的字符 } fclose(file); return 0; } ungetc # ungetc 将字符“放回”到输入流中，使其成为下一个要读取的字符。这在某些解析场景中非常有用。\nint ungetc(int c, FILE *stream); c：要放回的字符。 stream：文件流指针。 返回值：返回放回的字符，若失败返回 EOF。 #include \u0026lt;stdio.h\u0026gt; int main() { int c; FILE *file = fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening file!\\n\u0026#34;); return 1; } c = fgetc(file); if (c != EOF) { ungetc(c, file); // 将字符放回流中 c = fgetc(file); // 再次读取同一个字符 printf(\u0026#34;Character read again: %c\\n\u0026#34;, c); } fclose(file); return 0; } ungetc 最多只能将一个字符放回流中，放回后可以再次读取同一个字符。 在使用 ungetc 之前，确保放回的字符与流的状态一致。\n行输入函数 # gets（不推荐） # gets 从标准输入读取一行字符串，直到遇到换行符或文件结束符。由于存在缓冲区溢出的风险，gets 已被 C11 标准弃用。\nchar *gets(char *str); str：指向接收输入字符串的缓冲区指针。 返回值：返回输入字符串指针（str），如遇到 EOF 则返回 NULL。 Outdated!!!\n#include \u0026lt;stdio.h\u0026gt; int main() { char str[100]; printf(\u0026#34;Enter a string: \u0026#34;); gets(str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } 由于 gets 不检查输入是否超过缓冲区大小，可能导致缓冲区溢出并引发安全问题，强烈建议不要使用 gets，应使用更安全的 fgets。\nfgets # fgets 是读取一行输入的推荐方法，它可以避免缓冲区溢出问题。\nchar *fgets(char *str, int n, FILE *stream); str：指向接收输入字符串的缓冲区指针。 n：要读取的最大字符数（包括终止符）。 stream：文件流指针，stdin 表示标准输入。 返回值：返回 str，如果遇到 EOF 或发生错误，返回 NULL。 #include \u0026lt;stdio.h\u0026gt; int main() { char str[100]; printf(\u0026#34;Enter a string: \u0026#34;); if (fgets(str, 100, stdin) != NULL) { printf(\u0026#34;You entered: %s\u0026#34;, str); } else { printf(\u0026#34;Error reading input.\\n\u0026#34;); } return 0; } 注意,fgets 会保留输入的换行符\\n，如果你不想保留换行符，可以手动去掉它：\nstr[strcspn(str, \u0026#34;\\n\u0026#34;)] = \u0026#39;\\0\u0026#39;; fgets 是 安全 的，适合用于读取输入行或处理来自文件的文本行。\n低级别输入函数 # C 语言还提供了一些低级别的输入函数，这些函数直接与操作系统交互，通常用于更底层的输入/输出操作。\nread # read 是 UNIX 系统调用，用于从文件描述符读取原始数据。它允许对低级别的文件操作进行更多控制，通常在系统编程中使用。\nssize_t read(int fd, void *buf, size_t count); fd：文件描述符，表示从哪个文件或输入源读取数据。 buf：指向接收读取数据的缓冲区指针。 count：要读取的最大字节数。 返回值：返回读取的字节数，如果遇到 EOF 返回 0，如遇错误返回-1。 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { char buffer[100]; int fd = open(\u0026#34;input.txt\u0026#34;, O_RDONLY); if (fd == -1) { perror(\u0026#34;Error opening file\u0026#34;); return 1; } ssize_t bytesRead = read(fd, buffer, sizeof(buffer) - 1); if (bytesRead == -1) { perror(\u0026#34;Error reading file\u0026#34;); close(fd); return 1; } buffer[bytesRead] = \u0026#39;\\0\u0026#39;; // 确保字符串以空字符结束 printf(\u0026#34;Read from file: %s\\n\u0026#34;, buffer); close(fd); return 0; } 贴近操作系统是有代价的：不会自动处理文本行结束符或进行缓冲区管理，因此需要手动管理输入数据。\ngetch 和 getche # 这两个函数用于从标准输入读取单个字符，并且不需要按下回车键即可输入。它们通常用于处理键盘输入，特别是在控制台应用程序中。\ngetch：读取单个字符，不显示在屏幕上。 getche：读取单个字符，并显示在屏幕上。 这些函数不是标准 C 库的一部分，通常在 Windows 环境中由conio.h提供。\nint getch(void); int getche(void); #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;conio.h\u0026gt; int main() { char c; printf(\u0026#34;Press a key: \u0026#34;); c = getch(); // 使用 getch() 获取字符，但不显示 printf(\u0026#34;\\nYou pressed: %c\\n\u0026#34;, c); printf(\u0026#34;Press another key: \u0026#34;); c = getche(); // 使用 getche() 获取字符，并显示 printf(\u0026#34;\\nYou pressed: %c\\n\u0026#34;, c); return 0; } Windows Only!\n文件输入函数 # C 语言还提供了一些用于从文件中读取数据的函数。\nfread # fread 用于从文件中读取原始数据块，它通常用于二进制文件的读取。\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); ptr：指向接收读取数据的缓冲区指针。 size：每个数据块的大小（字节数）。 nmemb：要读取的块的数量。 stream：文件流指针。 返回值：返回成功读取的块数。 #include \u0026lt;stdio.h\u0026gt; int main() { FILE *file = fopen(\u0026#34;data.bin\u0026#34;, \u0026#34;rb\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening file!\\n\u0026#34;); return 1; } int data[5]; size_t bytesRead = fread(data, sizeof(int), 5, file); for (size_t i = 0; i \u0026lt; bytesRead; i++) { printf(\u0026#34;data[%zu] = %d\\n\u0026#34;, i, data[i]); } fclose(file); return 0; } fread 直接读取原始数据块，而不是格式化的数据。适用于读取二进制文件或自定义文件格式。 确保缓冲区足够大以容纳读取的数据，并检查返回值以确定是否成功读取。 getline # getline 用于从文件或标准输入中读取整行数据，包括换行符。它动态分配缓冲区以适应读取的数据行大小。\nssize_t getline(char **lineptr, size_t *n, FILE *stream); lineptr：指向缓冲区的指针指针。如果指针指向 NULL，getline 会自动分配缓冲区。 n：指向缓冲区大小的指针。 stream：文件流指针。 返回值：返回读取的字符数（包括换行符），如果遇到 EOF 返回-1。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char *line = NULL; size_t len = 0; ssize_t read; FILE *file = fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening file!\\n\u0026#34;); return 1; } while ((read = getline(\u0026amp;line, \u0026amp;len, file)) != -1) { printf(\u0026#34;Retrieved line of length %zu: %s\u0026#34;, read, line); } free(line); fclose(file); return 0; } getline 是 POSIX 标准的扩展函数\n安全输入（以scanf_s为例） # scanf_s 是 scanf 函数的安全版本，它通过增加对输入长度的控制，来避免输入数据超过目标缓冲区的大小，从而降低缓冲区溢出的风险。\nint scanf_s(const char *format, ...); format：格式字符串，与 scanf 的格式字符串类似，用于指定输入的数据类型。 \u0026hellip;：可变参数，指定要存储输入数据的变量地址。对于某些类型的输入（如字符串或字符数组），需要额外指定目标缓冲区的大小。 #include \u0026lt;stdio.h\u0026gt; int main() { char buffer[10]; int num; printf(\u0026#34;Enter a number and a string: \u0026#34;); scanf_s(\u0026#34;%d %9s\u0026#34;, \u0026amp;num, buffer, sizeof(buffer)); printf(\u0026#34;You entered: %d and %s\\n\u0026#34;, num, buffer); return 0; } 在这个示例中，%d 用于读取一个整数，%9s 用于读取最多 9 个字符的字符串。字符串后面的 sizeof(buffer) 指定了缓冲区的大小，以确保不会读入超过缓冲区容量的字符串。 scanf_s 在读取字符串时要求提供额外的参数，指定目标缓冲区的大小。这个参数是 必需 的。\n总结 # C 语言提供了多种输入方式来满足不同的需求，从简单的标准输入函数到复杂的文件输入函数，每种方式都有其适用场景和使用注意点：\n标准输入函数：scanf、fscanf、sscanf 用于读取格式化的数据，适合从标准输入或文件中获取结构化数据。 字符输入函数：getchar、fgetc、getc 用于逐字符读取输入，适合处理逐字符输入或文件内容。 行输入函数：fgets 和 getline 用于读取整行数据，fgets 安全性高，getline 适合处理动态长度行。 低级别输入函数：read、getch、getche 用于系统级编程或控制台输入，适合需要直接与硬件或操作系统交互的场景。 文件输入函数：fread 用于读取二进制数据块，适合处理二进制文件或自定义格式的文件。 掌握这些输入函数，可以让你在 C 语言编程中灵活地处理各种输入数据，满足不同的编程需要 AwA\n","externalUrl":null,"permalink":"/zh-cn/c/05/","section":"Cs","summary":"\u003ch2 class=\"relative group\"\u003e引入 \n    \u003cdiv id=\"%E5%BC%95%E5%85%A5\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%BC%95%E5%85%A5\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在 C 语言中，输入是从用户或文件等外部源获取数据并存储到程序变量中的过程。C 语言提供了多种方式来获取输入数据，包括标准输入函数、文件输入函数以及低级别的系统输入函数。\u003c/p\u003e","title":"Day5 - 标准输入","type":"c"},{"content":"众所周知，如果把所有代码都写在 main 函数里不可取的（如果你是oier我没有意见），所以我们需要将代码分割成多个函数，这样可以有效提高代码的可读性和可维护性。\n定义和声明 # 定义 # 函数定义是提供函数的具体实现，描述了函数的功能、输入参数以及输出结果的 类型。下面是通用的函数定义语法：\n返回值类型 函数名(参数类型 参数名, ...) { // 函数体 return 返回值; } 这样可能有点抽象，下面是一个最简单的例子：\nint add(int a, int b) { return a + b; } 让我们让我们根据通用公式来仔细看看这个函数都干了什么：\n函数名：add 返回值类型：int 参数类型：int a 和 int b 函数体：return a + b; 该函数 add 接受两个 int 类型的参数 a 和 b，返回它们的和，返回值类型为 int。\n声明（前置声明） # 函数声明（或称原型）是告诉编译器函数的名称、返回类型和参数类型，但不需要给出具体实现。通常，函数声明放在文件的开头或头文件中，因此也被称为前置声明\nint add(int a, int b); 像上面的代码，我们只告诉了编译器函数的形式，但是没有具体的实现，这个需要我们在后面补齐。\n调用 # 定义函数后，如果不去调用，那么只能是无用的代码，那么，我们该如何调用呢？调用时需要给定匹配的参数：\n通用公式：\n返回值类型 返回值名称 = 函数名(参数); 返回值是 可选 的 参数必须与函数定义中的一一对应 我们继续以上面实现好的add函数为例子\nint result = add(5, 3); // 调用函数，result 得到 8 参数传递 # 值传递 # 默认情况下，C 语言中的函数参数是按值传递的，即函数内部得到的是参数值的副本，函数的修改不会影响原始数据。\nvoid changeValue(int x) { x = 10; } int main() { int a = 5; changeValue(a); // 传递 a 的副本 printf(\u0026#34;%d\u0026#34;, a); // 输出仍然是 5 return 0; } 引用传递（指针传递） # 通过传递指针，可以使函数内部修改参数的值，从而影响原始变量。\nvoid changeValue(int *x) { *x = 10; } int main() { int a = 5; changeValue(\u0026amp;a); // 传递 a 的地址 printf(\u0026#34;%d\u0026#34;, a); // 输出 10 return 0; } 返回值 # C 语言的函数可以返回一个值，返回值类型在函数定义时指定。返回值通过 return 语句返回给调用者。函数只能返回一个值，但可以通过指针返回多个值（或使用结构体等）。\nint max(int x, int y) { if (x \u0026gt; y) return x; else return y; } 如果函数不需要返回值，返回类型应该声明为 void。\nvoid printHello() { printf(\u0026#34;Hello, World!\\n\u0026#34;); } 递归 # 递归是函数调用自身的机制。递归函数必须有终止条件，否则会陷入无限循环。\nint factorial(int n) { if (n == 0) return 1; // 终止条件 return n * factorial(n - 1); } 例如，factorial(5) 的计算过程如下：\nfactorial(5) = 5 _ factorial(4) factorial(4) = 4 _ factorial(3) factorial(3) = 3 _ factorial(2) factorial(2) = 2 _ factorial(1) factorial(1) = 1 \\* factorial(0) factorial(0) = 1 最终返回 120.\n变量作用域和生命周期 # 局部变量 # 在函数内部声明的变量，只能在函数内部访问，函数执行完毕后销毁。\nvoid foo() { int x = 10; // 局部变量 printf(\u0026#34;%d\u0026#34;, x); } int main() { foo(); // 输出 10 printf(\u0026#34;%d\u0026#34;, x); // 报错，x 未定义 } 全局变量 # 在所有函数外部声明的变量，可以被程序中所有函数访问，直到程序结束时才销毁。\nint globalVar = 10; // 全局变量 void foo() { printf(\u0026#34;%d\u0026#34;, globalVar); // 可以访问全局变量 } int main() { foo(); // 输出 10 printf(\u0026#34;%d\u0026#34;, globalVar); // 输出 10 } 静态变量 # 通过 static 关键字声明的局部变量，生命周期贯穿程序运行始终，但只能在函数内部访问。\nvoid foo() { static int count = 0; // 静态变量 count++; printf(\u0026#34;%d\u0026#34;, count); // 每次调用后，count 都会递增 } int main() { foo(); // 输出 1 foo(); // 输出 2 foo(); // 输出 3 } 函数指针 # 函数指针是一种可以指向函数的指针，用于函数的动态调用或作为 参数 传递给其他函数。\nint add(int a, int b) { return a + b; } int main() { int (*funcPtr)(int, int) = add; // 定义函数指针 int result = funcPtr(5, 3); // 通过指针调用函数 printf(\u0026#34;%d\u0026#34;, result); // 输出 8 return 0; } 函数指针使得程序更灵活，尤其在实现 回调函数 时非常有用。\n可变参数函数 # C 语言允许定义接受可变数量参数的函数，如标准库中的 printf。这种函数使用 \u0026lt;stdarg.h\u0026gt; 中的宏来处理参数列表。\n#include \u0026lt;stdarg.h\u0026gt; void printNumbers(int count, ...) { va_list args; va_start(args, count); for (int i = 0; i \u0026lt; count; i++) { int num = va_arg(args, int); printf(\u0026#34;%d \u0026#34;, num); } va_end(args); } int main() { printNumbers(3, 1, 2, 3); // 输出：1 2 3 return 0; } 内联函数 # 通过 inline 关键字，C 语言可以将小函数扩展为内联函数，避免函数调用的开销，从而提高程序性能。\ninline int square(int x) { return x * x; } 内联函数的定义建议放在头文件中，因为它要求编译器在调用时能够直接看到函数实现。\n函数重载（C 语言不支持，你可能需要神奇的 C++） # C 语言不支持函数重载，即不能像 C++ 那样定义多个同名函数并根据参数类型或数量来区分。在 C 语言中，函数名必须 唯一 。若要实现类似的功能，可以通过不同的函数名或使用可变参数来处理。\n例如，C++ 中可以这样做：\nint add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } 而在 C 中，你需要使用不同的函数名来区分：\nint add_int(int a, int b) { return a + b; } double add_double(double a, double b) { return a + b; } 函数返回指针 # C 语言函数可以返回指针，这是动态分配内存或返回数组等数据结构的常见方法。但需要注意指针的生命周期问题，避免返回无效的内存地址。\n返回局部变量的指针（危险！）\n局部变量在函数结束后被销毁，返回它们的指针会导致悬空指针（dangling pointer），这会引发 未定义行为。\nint* wrongFunction() { int localVar = 10; return \u0026amp;localVar; // 错误：局部变量的生命周期结束后，内存不可再访问 } 动态分配内存并返回指针（正确做法）\n通过 malloc 分配动态内存并返回指针，确保在函数外部能够继续使用这些数据。\nint* createArray(int size) { int *arr = (int *)malloc(size * sizeof(int)); if (arr == NULL) { printf(\u0026#34;Memory allocation failed\\n\u0026#34;); return NULL; } return arr; } 调用者需要负责释放动态分配的内存：\nint main() { int *arr = createArray(10); if (arr != NULL) { // 使用数组 free(arr); // 释放内存 } return 0; } 宏与函数 # C 语言中的宏是通过预处理器进行文本替换的，因此它们可以像函数一样使用。但宏与函数不同，宏的展开不会进行类型检查，并且可能引发难以发现的错误。\n#define SQUARE(x) ((x) * (x)) int main() { int a = 5; int result = SQUARE(a); // 正常 int b = 2; int result2 = SQUARE(a + b); // 意外：((a + b) * (a + b)) -\u0026gt; (7 * 7) = 49，而不是 (a^2 + 2ab + b^2) return 0; } 使用内联函数可以避免宏展开的问题，同时保留性能优势：\ninline int square(int x) { return x * x; } 静态函数 # 在 C 语言中，static 关键字不仅可以修饰变量，还可以修饰函数。如果将函数声明为 static，它的作用域将仅限于当前源文件。这样可以实现文件内函数的封装，避免其他文件误用该函数。\nstatic void helperFunction() { printf(\u0026#34;This is a static function\\n\u0026#34;); } int main() { helperFunction(); // 可以在当前文件中调用 return 0; } 静态函数 不会 暴露给其他文件，确保了实现细节的隐藏。\n变参宏与变参函数的结合 # 结合 C 语言的变参机制（\u0026lt;stdarg.h\u0026gt;）和宏，可以实现更灵活的函数定义。例如，printf 的实现就是通过变参函数来处理任意数量的参数。\n#include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void myPrint(const char \\*format, ...) { va_list args; va_start(args, format); vprintf(format, args); // vprintf 是处理变参的标准函数 va_end(args); } int main() { myPrint(\u0026#34;Hello %s, you have %d new messages\\n\u0026#34;, \u0026#34;Alice\u0026#34;, 5); return 0; } 这种机制常用于日志函数或调试工具中，可以处理不同类型和数量的输入。\n注意点 # 在 C 语言中，函数操作相关的未定义行为主要涉及函数调用、参数传递、返回值、指针操作等方面。以下是与函数相关的常见注意事项和可能导致未定义行为的操作。\n不匹配的函数指针调用 # 在 C 语言中，函数指针允许将函数地址赋值给指针并调用函数。但如果使用不匹配的函数指针类型调用函数，则会产生未定义行为。例如，将一个返回 int 类型的函数赋值给一个返回 void 的函数指针并调用时，会导致未定义行为。\nvoid myFunction() { printf(\u0026#34;This is a void function\\n\u0026#34;); } int main() { int (*funcPtr)(void) = (int (*)(void))myFunction; // 错误的强制类型转换 funcPtr(); // 调用不匹配的函数指针，未定义行为 return 0; } 递归函数无终止条件 # 递归函数在调用自身时，如果没有正确的终止条件，将导致无限递归，最终导致栈溢出。这种栈溢出虽然不是严格意义上的未定义行为，但通常会引发程序崩溃。\nvoid faultyRecursion() { faultyRecursion(); // 没有终止条件的递归 } int main() { faultyRecursion(); // 导致栈溢出，崩溃 return 0; } 解决方法：确保递归函数有明确的终止条件。\nvoid properRecursion(int count) { if (count \u0026lt;= 0) return; // 递归终止条件 properRecursion(count - 1); } 调用 main 函数 # C 语言标准规定，main 函数是程序的入口点，不应被显式调用。如果在程序中显式调用 main 函数，行为未定义。\nint main() { main(); // 显式调用 main 函数，未定义行为 return 0; } 未匹配的参数类型 # C 语言在函数调用时不会检查参数的类型匹配，如果函数的声明和定义的参数类型不一致，可能导致未定义行为。例如，传递一个 int 指针给一个期望 float 指针的函数。\nvoid func(float *f) { // ... } int main() { int x = 5; func(\u0026amp;x); // 传递不匹配的指针类型，未定义行为 return 0; } 未返回值的非 void 函数（相当常见的错误） # 如果一个非 void 类型的函数在某些路径下没有返回值，编译器可能不会捕捉到这个错误，从而导致未定义行为。\nint faultyFunction(int x) { if (x \u0026gt; 0) return x; // 仅在 x \u0026gt; 0 时返回值 // x \u0026lt;= 0 时未返回任何值，未定义行为 } 解决方法：确保非 void 函数在所有可能的路径中都有明确的返回值。\nint properFunction(int x) { if (x \u0026gt; 0) return x; return 0; // 为所有路径定义返回值 } 递归函数使用静态变量 # 递归函数使用静态变量时要小心，静态变量在整个程序生命周期内只有一份。如果递归函数修改静态变量，会导致意外的结果，甚至未定义行为，特别是在并发或递归调用中。\nvoid faultyRecursion(int n) { static int counter = 0; // 静态变量在每次递归调用中共享 counter++; if (n \u0026gt; 0) faultyRecursion(n - 1); printf(\u0026#34;%d\\n\u0026#34;, counter); } int main() { faultyRecursion(3); // 静态变量共享，递归结果不正确 return 0; } 总结 # 函数是 C 语言的核心机制，掌握函数的定义、声明、调用、参数传递、返回值、递归、变量作用域和生命周期、函数指针、宏与函数、静态函数、变参宏与变参函数的结合等知识点，可以帮助我们更好地理解和使用 C 语言。未来可期啊！\n","externalUrl":null,"permalink":"/zh-cn/c/06/","section":"Cs","summary":"\u003cp\u003e众所周知，如果把所有代码都写在 main 函数里不可取的（如果你是\u003ccode\u003eoier\u003c/code\u003e我没有意见），所以我们需要将代码分割成多个函数，这样可以有效提高代码的可读性和可维护性。\u003c/p\u003e","title":"Day6 - 函数那些事","type":"c"},{"content":"结构体（struct）是 C 语言中用来聚合不同类型数据的工具，它允许用户定义自己的复合数据类型。结构体可以用于存储和管理数据，提高程序的可读性和维护性。\n定义与基本使用 # 结构体的定义格式基本如下：\nstruct 结构体名 { 数据类型 成员名 1; 数据类型 成员名 2; ... }; 来一个简单的例子：\n#include \u0026lt;stdio.h\u0026gt; struct Book { char title[50]; char author[30]; int pages; float price; }; int main() { struct Book book1; // 为结构体的成员赋值 strcpy(book1.title, \u0026#34;C Programming\u0026#34;); strcpy(book1.author, \u0026#34;Dennis Ritchie\u0026#34;); book1.pages = 500; book1.price = 39.99; // 输出结构体的成员 printf(\u0026#34;Title: %s\\n\u0026#34;, book1.title); printf(\u0026#34;Author: %s\\n\u0026#34;, book1.author); printf(\u0026#34;Pages: %d\\n\u0026#34;, book1.pages); printf(\u0026#34;Price: %.2f\\n\u0026#34;, book1.price); return 0; } 输出结果:\nTitle: C Programming Author: Dennis Ritchie Pages: 500 Price: 39.99 定义与初始化 # 结构体变量可以有多种定义方式：\nstruct Book b1; // 定义一个结构体变量 b1 struct Book b2 = {\u0026#34;Title\u0026#34;, \u0026#34;Author\u0026#34;, 250, 59.99}; // 初始化 初始化结构体的方式 # 顺序初始化\nstruct Book book1 = {\u0026#34;C Language\u0026#34;, \u0026#34;Brian Kernighan\u0026#34;, 300, 45.5}; 指定成员初始化\nstruct Book book2 = {.title=\u0026#34;Data Structures\u0026#34;, .price=39.5}; 逐个赋值\nstruct Book book3; strcpy(book3.title, \u0026#34;Operating Systems\u0026#34;); strcpy(book3.author, \u0026#34;Silberschatz\u0026#34;); book3.pages = 700; book3.price = 99.9; 结构体数组 # 结构体数组存储多个结构体变量。\n#include \u0026lt;stdio.h\u0026gt; struct Student { int id; char name[20]; float score; }; int main() { struct Student students[3] = { {101, \u0026#34;Alice\u0026#34;, 95.5}, {102, \u0026#34;Bob\u0026#34;, 88.5}, {103, \u0026#34;Charlie\u0026#34;, 90.0} }; // 遍历结构体数组 for (int i = 0; i \u0026lt; 3; i++) { printf(\u0026#34;ID: %d, Name: %s, Score: %.2f\\n\u0026#34;, students[i].id, students[i].name, students[i].score); } return 0; } 输出结果\nID: 101, Name: Alice, Score: 95.50 ID: 102, Name: Bob, Score: 88.50 ID: 103, Name: Charlie, Score: 90.00 结构体指针 # 结构体指针可以指向结构体变量的地址，通过-\u0026gt;操作符访问成员。\n#include \u0026lt;stdio.h\u0026gt; struct Car { char name[20]; float price; }; int main() { struct Car car1 = {\u0026#34;Toyota\u0026#34;, 25000.0}; struct Car *ptr = \u0026amp;car1; // 定义结构体指针 // 使用指针访问成员 printf(\u0026#34;Car Name: %s\\n\u0026#34;, ptr-\u0026gt;name); printf(\u0026#34;Car Price: %.2f\\n\u0026#34;, ptr-\u0026gt;price); // 修改结构体内容 ptr-\u0026gt;price = 26000.0; printf(\u0026#34;Updated Price: %.2f\\n\u0026#34;, ptr-\u0026gt;price); return 0; } 输出结果\nCar Name: Toyota Car Price: 25000.00 Updated Price: 26000.00 结构体嵌套 # 结构体可以作为另一个结构体的成员。\n#include \u0026lt;stdio.h\u0026gt; struct Address { char city[20]; char street[20]; }; struct Person { char name[20]; int age; struct Address addr; // 嵌套结构体 }; int main() { struct Person p1; // 赋值 strcpy(p1.name, \u0026#34;John\u0026#34;); p1.age = 30; strcpy(p1.addr.city, \u0026#34;New York\u0026#34;); strcpy(p1.addr.street, \u0026#34;5th Avenue\u0026#34;); // 输出 printf(\u0026#34;Name: %s\\n\u0026#34;, p1.name); printf(\u0026#34;Age: %d\\n\u0026#34;, p1.age); printf(\u0026#34;City: %s\\n\u0026#34;, p1.addr.city); printf(\u0026#34;Street: %s\\n\u0026#34;, p1.addr.street); return 0; } 输出结果\nName: John Age: 30 City: New York Street: 5th Avenue 结构体作为函数参数 # 传值方式\n#include \u0026lt;stdio.h\u0026gt; struct Point { int x; int y; }; void printPoint(struct Point p) { // 结构体传值 printf(\u0026#34;Point: (%d, %d)\\n\u0026#34;, p.x, p.y); } int main() { struct Point p1 = {10, 20}; printPoint(p1); return 0; } 传指针方式\n#include \u0026lt;stdio.h\u0026gt; struct Point { int x; int y; }; void modifyPoint(struct Point \\*p) { // 结构体传指针 p-\u0026gt;x += 10; p-\u0026gt;y += 20; } int main() { struct Point p1 = {10, 20}; modifyPoint(\u0026amp;p1); printf(\u0026#34;Modified Point: (%d, %d)\\n\u0026#34;, p1.x, p1.y); return 0; } 结构体与 typedef # typedef 用于简化结构体的使用，相当于取个绰号。\n#include \u0026lt;stdio.h\u0026gt; typedef struct { char name[20]; int age; } Person; int main() { Person p1 = {\u0026#34;John\u0026#34;, 25}; printf(\u0026#34;Name: %s, Age: %d\\n\u0026#34;, p1.name, p1.age); return 0; } 结构体大小与内存对齐 # 结构体的大小受内存对齐规则影响：\n每个成员按自身类型的大小对齐。 结构体的总大小是最大成员大小的整数倍。 #include \u0026lt;stdio.h\u0026gt; struct Test { char a; // 1 字节 int b; // 4 字节 char c; // 1 字节 }; int main() { printf(\u0026#34;Size of struct Test: %zu bytes\\n\u0026#34;, sizeof(struct Test)); return 0; } 输出：（可能为 12 字节，取决于编译器） Size of struct Test: 12 bytes 联合体与结构体的区别 # 结构体：所有成员独立存在，占用的内存是所有成员大小之和。 联合体：所有成员共享一块内存，大小取决于最大成员。 #include \u0026lt;stdio.h\u0026gt; union Data { int i; float f; char str[20]; }; int main() { union Data data; data.i = 10; printf(\u0026#34;Int: %d\\n\u0026#34;, data.i); data.f = 3.14; printf(\u0026#34;Float: %.2f\\n\u0026#34;, data.f); strcpy(data.str, \u0026#34;Hello\u0026#34;); printf(\u0026#34;String: %s\\n\u0026#34;, data.str); return 0; } 实际应用 # 结构体在实际项目中非常有用，例如：\n学生管理系统：存储学生信息。 图形系统：定义点、线、面等结构。 文件系统：定义文件属性（名称、大小、路径等）。 当然，还有学校的 C 语言考试 ","externalUrl":null,"permalink":"/zh-cn/c/07/","section":"Cs","summary":"\u003cp\u003e结构体（struct）是 C 语言中用来聚合不同类型数据的工具，它允许用户定义自己的复合数据类型。结构体可以用于存储和管理数据，提高程序的可读性和维护性。\u003c/p\u003e","title":"Day7 - 结构体","type":"c"},{"content":"链表（Linked List）是 C 语言中一种常见的数据结构，属于线性数据结构。它不同于数组，链表的长度可以动态变化，适合需要频繁插入、删除元素的场景，当然，也是大学 c 语言考试中不可缺少的一部分。下面将详细介绍链表的原理、类型、实现方式、应用及其优缺点。\n基本概念 # 链表由多个节点（Node）组成，每个节点包含两个部分：\n数据域（Data）：存储节点的数据。 指针域（Pointer）：指向下一个节点的地址。 链表通过指针将各个节点串联起来，形成一个链式结构。\n分类 # 链表根据结构的不同，可以分为以下几种类型：\n单向链表（Singly Linked List） # 每个节点只有一个指针，指向下一个节点。 适合从头到尾的单向遍历。 最后一个节点的指针为 NULL。 双向链表（Doubly Linked List） # 每个节点有两个指针：一个指向前一个节点，另一个指向后一个节点。 支持双向遍历，插入和删除操作更灵活。 需要额外的内存来存储两个指针。 循环链表（Circular Linked List） # 尾节点的指针指向头节点，形成一个环状结构。 可以是单向循环链表，也可以是双向循环链表。 适用于需要循环访问的场景。 多重链表（Multi Linked List） # 每个节点可以有多个指针，形成复杂的链表结构。 常用于表示图、稀疏矩阵等复杂数据结构。 链表与数组的比较 # 特性 链表 数组 存储方式 动态分配，分散存储 静态分配，连续存储 访问时间 O(n)，需逐个节点访问 O(1)，可直接访问索引 插入/删除 高效，不需要移动元素 低效，需要移动元素 内存使用 节点需额外的指针空间 仅存储数据，无额外开销 单向链表 # 节点定义 # 单向链表的节点定义如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义单向链表的节点结构 struct Node { int data; // 数据域 struct Node* next; // 指针域，指向下一个节点 }; 创建节点 # 节点的内存通过 malloc 函数动态分配：\nstruct Node* createNode(int data) { struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); if (newNode == NULL) { printf(\u0026#34;内存分配失败\\n\u0026#34;); exit(1); } newNode-\u0026gt;data = data; // 设置数据域 newNode-\u0026gt;next = NULL; // 初始化指针域 return newNode; } 基本操作 # 插入节点 # 在链表头部插入\nstruct Node* insertAtHead(struct Node* head, int data) { struct Node* newNode = createNode(data); newNode-\u0026gt;next = head; // 新节点的指针指向旧的头节点 return newNode; // 返回新的头节点 } 在链表尾部插入\nvoid insertAtTail(struct Node** head, int data) { struct Node* newNode = createNode(data); if (*head == NULL) { *head = newNode; return; } struct Node* temp = *head; while (temp-\u0026gt;next != NULL) { temp = temp-\u0026gt;next; } temp-\u0026gt;next = newNode; } 删除节点 # 删除第一个匹配指定值的节点\nstruct Node* deleteNode(struct Node* head, int key) { struct Node* temp = head; struct Node* prev = NULL; // 处理头节点 if (temp != NULL \u0026amp;\u0026amp; temp-\u0026gt;data == key) { head = temp-\u0026gt;next; free(temp); return head; } // 查找要删除的节点 while (temp != NULL \u0026amp;\u0026amp; temp-\u0026gt;data != key) { prev = temp; temp = temp-\u0026gt;next; } if (temp == NULL) return head; // 未找到节点 prev-\u0026gt;next = temp-\u0026gt;next; // 跳过要删除的节点 free(temp); // 释放内存 return head; } 遍历链表 # 通过循环逐个访问节点\nvoid printList(struct Node* head) { struct Node* temp = head; while (temp != NULL) { printf(\u0026#34;%d -\u0026gt; \u0026#34;, temp-\u0026gt;data); temp = temp-\u0026gt;next; } printf(\u0026#34;NULL\\n\u0026#34;); } 完整代码 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义链表节点结构 struct Node { int data; struct Node* next; }; // 创建新节点 struct Node* createNode(int data) { struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-\u0026gt;data = data; newNode-\u0026gt;next = NULL; return newNode; } // 头部插入 struct Node* insertAtHead(struct Node* head, int data) { struct Node* newNode = createNode(data); newNode-\u0026gt;next = head; return newNode; } // 遍历链表 void printList(struct Node* head) { struct Node* temp = head; while (temp != NULL) { printf(\u0026#34;%d -\u0026gt; \u0026#34;, temp-\u0026gt;data); temp = temp-\u0026gt;next; } printf(\u0026#34;NULL\\n\u0026#34;); } // 主函数 int main() { struct Node* head = NULL; // 初始化链表为空 // 插入元素 head = insertAtHead(head, 10); head = insertAtHead(head, 20); head = insertAtHead(head, 30); printf(\u0026#34;链表内容：\\n\u0026#34;); printList(head); return 0; } 双向链表 # 在双向链表中，每个节点包含三个部分：\n数据域（data） 指向前一个节点的指针（prev） 指向后一个节点的指针（next） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义双向链表的节点结构 struct DNode { int data; // 数据域 struct DNode* prev; // 指向前一个节点 struct DNode* next; // 指向后一个节点 }; 创建新节点 # struct DNode* createNode(int data) { struct DNode* newNode = (struct DNode*)malloc(sizeof(struct DNode)); if (newNode == NULL) { printf(\u0026#34;内存分配失败\\n\u0026#34;); exit(1); } newNode-\u0026gt;data = data; newNode-\u0026gt;prev = NULL; newNode-\u0026gt;next = NULL; return newNode; } 插入操作 # 在链表头部插入 # struct DNode* insertAtHead(struct DNode* head, int data) { struct DNode* newNode = createNode(data); if (head != NULL) { head-\u0026gt;prev = newNode; newNode-\u0026gt;next = head; } return newNode; // 新节点成为头节点 } 在链表尾部插入 # void insertAtTail(struct DNode* head, int data) { struct DNode* newNode = createNode(data); struct DNode* temp = head; while (temp-\u0026gt;next != NULL) { // 找到尾节点 temp = temp-\u0026gt;next; } temp-\u0026gt;next = newNode; newNode-\u0026gt;prev = temp; } 删除节点 # 删除包含指定值的节点\nstruct DNode* deleteNode(struct DNode* head, int key) { struct DNode* temp = head; // 查找要删除的节点 while (temp != NULL \u0026amp;\u0026amp; temp-\u0026gt;data != key) { temp = temp-\u0026gt;next; } if (temp == NULL) return head; // 未找到节点 if (temp-\u0026gt;prev != NULL) { temp-\u0026gt;prev-\u0026gt;next = temp-\u0026gt;next; // 更新前节点的next } else { head = temp-\u0026gt;next; // 删除的是头节点 } if (temp-\u0026gt;next != NULL) { temp-\u0026gt;next-\u0026gt;prev = temp-\u0026gt;prev; // 更新后节点的prev } free(temp); return head; } 遍历链表 # 从头到尾遍历\nvoid printList(struct DNode* head) { struct DNode* temp = head; printf(\u0026#34;正向遍历：\\n\u0026#34;); while (temp != NULL) { printf(\u0026#34;%d -\u0026gt; \u0026#34;, temp-\u0026gt;data); temp = temp-\u0026gt;next; } printf(\u0026#34;NULL\\n\u0026#34;); } 完整示例 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 双向链表的节点结构 struct DNode { int data; struct DNode* prev; struct DNode* next; }; // 创建新节点 struct DNode* createNode(int data) { struct DNode* newNode = (struct DNode*)malloc(sizeof(struct DNode)); newNode-\u0026gt;data = data; newNode-\u0026gt;prev = NULL; newNode-\u0026gt;next = NULL; return newNode; } // 在头部插入节点 struct DNode* insertAtHead(struct DNode* head, int data) { struct DNode* newNode = createNode(data); if (head != NULL) { head-\u0026gt;prev = newNode; newNode-\u0026gt;next = head; } return newNode; } // 遍历链表 void printList(struct DNode* head) { struct DNode* temp = head; printf(\u0026#34;链表内容：\\n\u0026#34;); while (temp != NULL) { printf(\u0026#34;%d -\u0026gt; \u0026#34;, temp-\u0026gt;data); temp = temp-\u0026gt;next; } printf(\u0026#34;NULL\\n\u0026#34;); } // 主函数 int main() { struct DNode* head = NULL; head = insertAtHead(head, 10); head = insertAtHead(head, 20); head = insertAtHead(head, 30); printList(head); return 0; } 循环链表 # 循环链表的特点是尾节点的 next 指针指向头节点，形成一个闭环。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义循环链表的节点结构 struct CNode { int data; struct CNode* next; }; 创建新节点 # struct CNode* createNode(int data) { struct CNode* newNode = (struct CNode*)malloc(sizeof(struct CNode)); if (newNode == NULL) { printf(\u0026#34;内存分配失败\\n\u0026#34;); exit(1); } newNode-\u0026gt;data = data; newNode-\u0026gt;next = newNode; // 初始时指向自己 return newNode; } 插入操作 # 在头部插入 # struct CNode* insertAtHead(struct CNode* tail, int data) { struct CNode* newNode = createNode(data); if (tail == NULL) { return newNode; // 如果链表为空，新节点即是尾节点 } newNode-\u0026gt;next = tail-\u0026gt;next; // 新节点指向原头节点 tail-\u0026gt;next = newNode; // 尾节点指向新节点 return tail; } 在尾部插入 # struct CNode* insertAtTail(struct CNode* tail, int data) { struct CNode* newNode = createNode(data); if (tail == NULL) { return newNode; // 如果链表为空，新节点即是尾节点 } newNode-\u0026gt;next = tail-\u0026gt;next; // 新节点指向头节点 tail-\u0026gt;next = newNode; // 尾节点指向新节点 return newNode; // 新节点成为尾节点 } 遍历循环链表 # void printList(struct CNode* tail) { if (tail == NULL) return; struct CNode* temp = tail-\u0026gt;next; // 从头节点开始 do { printf(\u0026#34;%d -\u0026gt; \u0026#34;, temp-\u0026gt;data); temp = temp-\u0026gt;next; } while (temp != tail-\u0026gt;next); // 循环到头节点结束 printf(\u0026#34;(HEAD)\\n\u0026#34;); } 完整的循环链表示例 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义循环链表的节点 struct CNode { int data; struct CNode* next; }; // 创建节点 struct CNode* createNode(int data) { struct CNode* newNode = (struct CNode*)malloc(sizeof(struct CNode)); newNode-\u0026gt;data = data; newNode-\u0026gt;next = newNode; return newNode; } // 在尾部插入节点 struct CNode* insertAtTail(struct CNode* tail, int data) { struct CNode* newNode = createNode(data); if (tail == NULL) { return newNode; } newNode-\u0026gt;next = tail-\u0026gt;next; tail-\u0026gt;next = newNode; return newNode; } // 遍历链表 void printList(struct CNode* tail) { if (tail == NULL) return; struct CNode* temp = tail-\u0026gt;next; do { printf(\u0026#34;%d -\u0026gt; \u0026#34;, temp-\u0026gt;data); temp = temp-\u0026gt;next; } while (temp != tail-\u0026gt;next); printf(\u0026#34;(HEAD)\\n\u0026#34;); } // 主函数 int main() { struct CNode* tail = NULL; tail = insertAtTail(tail, 10); tail = insertAtTail(tail, 20); tail = insertAtTail(tail, 30); printList(tail); return 0; } 总结 # 链表：是一种线性数据结构，通过指针将多个节点串联起来。 双向链表：支持双向遍历，插入和删除操作更灵活。 循环链表：尾节点指向头节点，适合循环访问的场景。 链表是一种动态数据结构，灵活性高，适用于需要频繁插入和删除元素的场景。掌握链表的关键在于理解指针的使用，包括节点的创建、链接、遍历和释放内存。\n","externalUrl":null,"permalink":"/zh-cn/c/08/","section":"Cs","summary":"\u003cp\u003e链表（Linked List）是 C 语言中一种常见的数据结构，属于线性数据结构。它不同于数组，链表的长度可以动态变化，适合需要频繁插入、删除元素的场景，当然，也是大学 c 语言考试中不可缺少的一部分。下面将详细介绍链表的原理、类型、实现方式、应用及其优缺点。\u003c/p\u003e","title":"Day8 - 链表","type":"c"},{"content":"文件操作是 C 语言中的一项重要功能，用于实现对磁盘文件的读写、创建、修改等操作。C 语言通过标准库函数提供了强大的文件操作支持，这些函数位于头文件 \u0026lt;stdio.h\u0026gt; 中。\n文件的基本概念 # 文件是存储在磁盘上的数据集合，可以是文本文件或二进制文件：\n文本文件：以可读字符存储（ASCII/UTF-8 等编码），适合人类阅读。 二进制文件：以原始数据的形式存储，不能直接阅读。 在 C 语言中，文件操作基于文件指针 FILE*，用于引用文件。\n文件操作的基本步骤 # 文件操作的基本流程分为四步：\n打开文件（fopen() 或 freopen()） 读/写文件（如：fscanf(), fprintf(), fread(), fwrite() 等） 关闭文件（fclose()） 处理错误（通过返回值或 ferror() 检测） 文件指针 # FILE* 是一个指向文件的指针，用于操作文件。打开文件后，会返回一个指向文件流的指针，该指针用于后续的读写操作。\n文件打开与关闭 # 打开文件：fopen() # 语法：\nFILE* fopen(const char* filename, const char* mode); 参数说明：\nfilename：文件名（包含路径） mode：文件的打开模式 常见的文件模式：\n模式 含义 \u0026quot;r\u0026quot; 以只读模式打开文件，文件必须存在 \u0026quot;w\u0026quot; 以写入模式打开文件，若文件存在则清空内容 \u0026quot;a\u0026quot; 以追加模式打开文件，不存在则创建 \u0026quot;r+\u0026quot; 以读写模式打开文件，文件必须存在 \u0026quot;w+\u0026quot; 以读写模式打开文件，若文件存在则清空内容 \u0026quot;a+\u0026quot; 以读写模式打开文件，从文件尾部追加数据 \u0026quot;b\u0026quot; 二进制模式（可与以上模式组合，如 \u0026quot;rb\u0026quot;） 示例：\nFILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;); if (fp == NULL) { printf(\u0026#34;文件打开失败！\\n\u0026#34;); return 1; } 关闭文件：fclose() # 语法：\nint fclose(FILE* stream); 关闭文件并释放资源。成功返回 0，失败返回 EOF。\n示例：\nfclose(fp); 二合一 # #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;); // 以写入模式打开文件 if (fp == NULL) { // 检查文件是否打开成功 printf(\u0026#34;文件打开失败！\\n\u0026#34;); return 1; } printf(\u0026#34;文件打开成功！\\n\u0026#34;); fclose(fp); // 关闭文件 printf(\u0026#34;文件关闭成功！\\n\u0026#34;); return 0; } 文件读写 # 文本文件的读写 # 写入文本文件：fprintf() # 用于以格式化文本的方式写入数据。\n语法：\nint fprintf(FILE* stream, const char* format, ...); 示例：\nFILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;); if (fp != NULL) { fprintf(fp, \u0026#34;姓名：%s\\n年龄：%d\\n\u0026#34;, \u0026#34;张三\u0026#34;, 25); fclose(fp); } 读取文本文件：fscanf() # 用于以格式化文本的方式读取数据。\n语法：\nint fscanf(FILE* stream, const char* format, ...); 示例：\nFILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;); char name[50]; int age; if (fp != NULL) { fscanf(fp, \u0026#34;姓名：%s\\n年龄：%d\\n\u0026#34;, name, \u0026amp;age); printf(\u0026#34;姓名：%s, 年龄：%d\\n\u0026#34;, name, age); fclose(fp); } 字符操作：fgetc() 和 fputc() # fgetc(FILE* stream)：从文件中读取一个字符 fputc(int ch, FILE* stream)：向文件中写入一个字符 示例：\nFILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;); if (fp != NULL) { fputc(\u0026#39;A\u0026#39;, fp); // 写入字符 \u0026#39;A\u0026#39; fclose(fp); } fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;); if (fp != NULL) { char ch = fgetc(fp); // 读取字符 printf(\u0026#34;读取的字符：%c\\n\u0026#34;, ch); fclose(fp); } 行操作：fgets() 和 fputs() # fgets(char* str, int n, FILE* stream)：读取一行，最多读取 n-1 个字符 fputs(const char* str, FILE* stream)：写入一行 示例：\nFILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;); if (fp != NULL) { fputs(\u0026#34;Hello, World!\\n\u0026#34;, fp); fclose(fp); } fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;); if (fp != NULL) { char line[100]; fgets(line, sizeof(line), fp); // 读取一行 printf(\u0026#34;读取的行：%s\u0026#34;, line); fclose(fp); } 两个例子 # #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;); // 以写模式打开文件 if (fp == NULL) { printf(\u0026#34;文件打开失败！\\n\u0026#34;); return 1; } fprintf(fp, \u0026#34;姓名：%s\\n\u0026#34;, \u0026#34;张三\u0026#34;); fprintf(fp, \u0026#34;年龄：%d\\n\u0026#34;, 25); // 写入文本 fclose(fp); // 关闭文件 printf(\u0026#34;写入完成！\\n\u0026#34;); return 0; } #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;); // 以读模式打开文件 if (fp == NULL) { printf(\u0026#34;文件打开失败！\\n\u0026#34;); return 1; } char name[50]; int age; fscanf(fp, \u0026#34;姓名：%s\\n\u0026#34;, name); fscanf(fp, \u0026#34;年龄：%d\\n\u0026#34;, \u0026amp;age); // 按格式读取内容 printf(\u0026#34;姓名：%s\\n\u0026#34;, name); printf(\u0026#34;年龄：%d\\n\u0026#34;, age); fclose(fp); // 关闭文件 return 0; } 二进制文件的读写 # 写入二进制文件：fwrite() # 用于将数据块写入文件。\n语法：\nsize_t fwrite(const void* ptr, size_t size, size_t count, FILE* stream); 示例：\nFILE* fp = fopen(\u0026#34;data.bin\u0026#34;, \u0026#34;wb\u0026#34;); int data[] = {1, 2, 3, 4, 5}; fwrite(data, sizeof(int), 5, fp); fclose(fp); 读取二进制文件：fread() # 用于从文件中读取数据块。\n语法：\nsize_t fread(void* ptr, size_t size, size_t count, FILE* stream); 示例：\nFILE* fp = fopen(\u0026#34;data.bin\u0026#34;, \u0026#34;rb\u0026#34;); int data[5]; fread(data, sizeof(int), 5, fp); for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;%d \u0026#34;, data[i]); } fclose(fp); #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;data.bin\u0026#34;, \u0026#34;wb\u0026#34;); // 打开二进制文件 if (fp == NULL) { printf(\u0026#34;文件打开失败！\\n\u0026#34;); return 1; } int numbers[] = {10, 20, 30, 40, 50}; fwrite(numbers, sizeof(int), 5, fp); // 写入5个整数 fclose(fp); printf(\u0026#34;二进制数据写入完成！\\n\u0026#34;); return 0; } #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;data.bin\u0026#34;, \u0026#34;rb\u0026#34;); // 打开二进制文件 if (fp == NULL) { printf(\u0026#34;文件打开失败！\\n\u0026#34;); return 1; } int numbers[5]; fread(numbers, sizeof(int), 5, fp); // 读取5个整数 for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;数字%d: %d\\n\u0026#34;, i + 1, numbers[i]); } fclose(fp); return 0; } 文件指针的位置操作 # (1) ftell() # 返回当前文件指针的位置。\n语法：\nlong ftell(FILE* stream); (2) fseek() # 移动文件指针到指定位置。\n语法：\nint fseek(FILE* stream, long offset, int origin); 示例：\nFILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;); fseek(fp, 10, SEEK_SET); // 将指针移动到文件的第10个字节 printf(\u0026#34;当前位置：%ld\\n\u0026#34;, ftell(fp)); fclose(fp); (3) rewind() # 将文件指针重置到文件开头。\n语法：\nvoid rewind(FILE* stream); #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;); if (fp == NULL) { printf(\u0026#34;文件打开失败！\\n\u0026#34;); return 1; } fseek(fp, 5, SEEK_SET); // 将指针移动到文件的第5个字节 long pos = ftell(fp); // 获取当前指针位置 printf(\u0026#34;当前指针位置：%ld\\n\u0026#34;, pos); fclose(fp); return 0; } 7. 文件操作的错误处理 # (1) ferror() # 检查文件操作是否出错。\n语法：\nint ferror(FILE* stream); (2) perror() # 打印文件操作错误信息。\n语法：\nvoid perror(const char* str); #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;nonexistent.txt\u0026#34;, \u0026#34;r\u0026#34;); // 尝试打开不存在的文件 if (fp == NULL) { perror(\u0026#34;文件打开失败\u0026#34;); // 打印错误信息 return 1; } char ch = fgetc(fp); if (ferror(fp)) { // 检查是否发生错误 printf(\u0026#34;文件读取出错！\\n\u0026#34;); } fclose(fp); return 0; } 8. 常见问题与注意事项 # 文件打开失败要检查返回值是否为 NULL。 文件操作完成后务必关闭文件以释放资源。 注意文件读写模式的正确选择，否则可能导致数据丢失。 处理二进制文件时要确保读取/写入的数据大小匹配。 以上代码涵盖了所有常见的 C 语言文件操作，并且每个功能都配有完整的示例代码，可以直接运行测试。\n","externalUrl":null,"permalink":"/zh-cn/c/09/","section":"Cs","summary":"\u003cp\u003e文件操作是 C 语言中的一项重要功能，用于实现对磁盘文件的读写、创建、修改等操作。C 语言通过标准库函数提供了强大的文件操作支持，这些函数位于头文件 \u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e 中。\u003c/p\u003e","title":"Day9 - 文件操作","type":"c"},{"content":"","externalUrl":null,"permalink":"/en/","section":"MaxQian's Blog","summary":"","title":"MaxQian's Blog","type":"page"},{"content":"","externalUrl":null,"permalink":"/zh-cn/rust/","section":"Rusts","summary":"","title":"Rusts","type":"rust"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 前言 # 在多线程编程中，正确管理线程同步是确保程序稳定性和性能的关键。C++ 提供了多种工具来帮助开发者实现线程同步，例如 std::mutex、std::lock_guard 和 std::unique_lock 等。这些工具虽然强大，但在某些复杂场景下，可能需要更灵活的锁管理方式。比如说有的时候我在加锁后，在局部代码中需要释放锁，然后后续运行又需要加锁，这个时候我们虽然可以通过unlock和lock组合完成，但是代码变长后难免会出现遗忘的情况，从而产生错误。那么，本文将介绍一种名为“Antilock”的模式，它能够在需要时暂时释放锁，并在操作完成后自动重新获取锁，从而避免潜在的死锁和遗忘问题。\n本文的理念来自 Antilock 模式\n概念 # 互斥锁与 RAII 模式 # 在 C++ 中，互斥锁（mutex）用于保护共享资源，防止多个线程同时访问而导致数据不一致。为了简化锁的管理，C++ 标准库引入了 RAII（Resource Acquisition Is Initialization）模式。RAII 模式通过在对象的构造函数中获取资源，在析构函数中释放资源，确保资源管理的安全性。 例如，std::lock_guard 就是一个常用的 RAII 类型，它会在构造时自动锁定互斥锁，并在析构时自动解锁：\nstd::mutex mtx; { std::lock_guard\u0026lt;std::mutex\u0026gt; guard(mtx); // 这里的代码块在锁的保护下执行 } // 离开作用域时，锁自动释放 Antilock 模式 # Antilock 模式是一种反作用的锁管理策略，它的作用是暂时释放一个已经锁定的互斥锁，并在特定操作完成后重新获取该锁。这种模式特别适合需要在锁的保护下执行部分操作，但又需要在某些时候释放锁以避免死锁的场景。\n那么这种机制是否可以称为RRII呢？即Resource Release Is Initialization！\n实现 # 基本实现 # 我们首先定义一个简单的 Antilock 模板类，它可以接受一个互斥锁对象，在构造时解锁该互斥锁，并在析构时重新锁定它：\ntemplate\u0026lt;typename Mutex\u0026gt; class Antilock { public: Antilock() = default; explicit Antilock(Mutex\u0026amp; mutex) : m_mutex(std::addressof(mutex)) { if (m_mutex) { // 这里做一个检查如果互斥锁有效 m_mutex-\u0026gt;unlock(); std::cout \u0026lt;\u0026lt; \u0026#34;[Antilock] Lock released.\\n\u0026#34;; } } ~Antilock() { if (m_mutex) { m_mutex-\u0026gt;lock(); std::cout \u0026lt;\u0026lt; \u0026#34;[Antilock] Lock reacquired.\\n\u0026#34;; } } private: Mutex* m_mutex = nullptr; // 指向互斥锁的指针 }; 这个简单的 Antilock 类在构造时解锁传入的 Mutex 对象，并在析构时重新锁定它。通过这种方式，可以安全地在一个作用域内暂时释放锁，执行其他操作。\n支持 Guard 的扩展 # 在某些情况下，我们可能不希望 Antilock 直接操作互斥锁，而是通过一个管理锁的 Guard 对象来间接操作锁。例如，我们可以使用 std::unique_lock 作为 Guard，这样可以更加灵活。\n下面是一个简单的例子：\ntemplate\u0026lt;typename Guard\u0026gt; class Antilock { public: Antilock() = default; explicit Antilock(Guard\u0026amp; guard) : m_mutex(guard.mutex()) { // 使用 Guard 的 mutex 方法获取互斥锁 if (m_mutex) { m_mutex-\u0026gt;unlock(); std::cout \u0026lt;\u0026lt; \u0026#34;[Antilock] Lock released.\\n\u0026#34;; } } ~Antilock() { if (m_mutex) { m_mutex-\u0026gt;lock(); std::cout \u0026lt;\u0026lt; \u0026#34;[Antilock] Lock reacquired.\\n\u0026#34;; } } private: typename Guard::mutex_type* m_mutex = nullptr; }; 在这个版本中，Antilock 使用 Guard 对象的 mutex() 方法来获取互斥锁的指针，从而实现对锁的间接管理。\n使用场景 # 调用外部操作 # 假设我们有一个共享资源需要在多线程环境下访问，同时我们需要在访问资源的过程中调用一个外部操作。由于外部操作可能会导致长时间等待或死锁，我们希望在执行外部操作时释放锁，操作完成后重新获取锁。 以下是一个使用 Antilock 模式的示例：\nclass Resource { public: void DoSomething() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(m_mutex); std::cout \u0026lt;\u0026lt; \u0026#34;[Resource] Doing something under lock.\\n\u0026#34;; // 临时释放锁，执行外部操作 Antilock\u0026lt;std::unique_lock\u0026lt;std::mutex\u0026gt;\u0026gt; antilock(lock); m_data = ExternalOperation(); std::cout \u0026lt;\u0026lt; \u0026#34;[Resource] Finished doing something.\\n\u0026#34;; } private: int ExternalOperation() { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 std::cout \u0026lt;\u0026lt; \u0026#34;[External] External operation completed.\\n\u0026#34;; return 42; // 返回一个结果 } std::mutex m_mutex; // 保护共享数据的互斥锁 int m_data = 0; // 共享数据 }; 在这个示例中，DoSomething 方法使用 std::unique_lock 锁定互斥锁，然后使用 Antilock 在执行外部操作时释放锁。外部操作完成后，锁会被自动重新获取。\n多线程 # 为了更好地展示 Antilock 模式的优势，我们可以创建多个线程同时访问共享资源\nint main() { Resource resource; // 创建多个线程来访问共享资源 std::vector\u0026lt;std::thread\u0026gt; threads; for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(\u0026amp;Resource::DoSomething, \u0026amp;resource); } // 等待所有线程完成 for (auto\u0026amp; thread : threads) { thread.join(); } return 0; } 在这个例子中，我们创建了多个线程，每个线程都会调用 Resource 对象的 DoSomething 方法。Antilock 模式确保了在外部操作期间，锁会被暂时释放，从而避免了可能的死锁。\n完整例子 # CE链接\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;chrono\u0026gt; // 定义支持 Guard 的 Antilock 模板类 template\u0026lt;typename Guard\u0026gt; class Antilock { public: Antilock() = default; explicit Antilock(Guard\u0026amp; guard) : m_mutex(guard.mutex()) { // 使用 Guard 的 mutex 方法获取互斥锁 if (m_mutex) { m_mutex-\u0026gt;unlock(); std::cout \u0026lt;\u0026lt; \u0026#34;[Antilock] Lock released.\\n\u0026#34;; } } ~Antilock() { if (m_mutex) { m_mutex-\u0026gt;lock(); std::cout \u0026lt;\u0026lt; \u0026#34;[Antilock] Lock reacquired.\\n\u0026#34;; } } private: typename Guard::mutex_type* m_mutex = nullptr; // 指向互斥锁的指针 }; // 模拟一个资源类，包含一个互斥锁和条件变量来保护和协调共享数据 class Resource { public: void DoSomething() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(m_mutex); // 使用条件变量等待某些条件满足 m_condVar.wait(lock, [this] { return m_data.load() == 0; }); std::cout \u0026lt;\u0026lt; \u0026#34;[Resource] Doing something under lock.\\n\u0026#34;; try { // 临时释放锁，执行外部操作 Antilock\u0026lt;std::unique_lock\u0026lt;std::mutex\u0026gt;\u0026gt; antilock(lock); m_data.store(ExternalOperation()); } catch (const std::exception\u0026amp; ex) { std::cerr \u0026lt;\u0026lt; \u0026#34;[Error] Exception caught: \u0026#34; \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 处理异常的情况下，需要确保锁状态的一致性 } std::cout \u0026lt;\u0026lt; \u0026#34;[Resource] Finished doing something.\\n\u0026#34;; m_condVar.notify_all(); // 通知其他等待的线程 } private: int ExternalOperation() { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 std::cout \u0026lt;\u0026lt; \u0026#34;[External] External operation completed.\\n\u0026#34;; return 42; // 返回一个结果 } std::mutex m_mutex; // 保护共享数据的互斥锁 std::condition_variable m_condVar; // 用于线程同步的条件变量 std::atomic\u0026lt;int\u0026gt; m_data{0}; // 线程安全的共享数据 }; // 主函数 int main() { Resource resource; // 创建多个线程来访问共享资源 std::vector\u0026lt;std::thread\u0026gt; threads; for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(\u0026amp;Resource::DoSomething, \u0026amp;resource); } // 等待所有线程完成 for (auto\u0026amp; thread : threads) { thread.join(); } return 0; } 总结 # 优点 # 灵活性：Antilock 模式允许在需要时暂时释放锁，从而执行一些可能导致死锁的操作。 自动管理：通过 RAII 模式，Antilock 在作用域结束时自动重新获取锁，无需手动管理锁的状态。 注意事项 # 锁状态的复杂性：使用 Antilock 可能会增加锁状态的复杂性，尤其是在嵌套锁定或递归锁定的场景中。 异常处理：在实现 Antilock 模式时，确保在出现异常的情况下，锁能够被正确管理，以避免锁定状态不一致的问题。 通过本文的介绍，希望大家能对 Antilock 模式有了更深入的了解，并能够在实际项目中应用这一模式来解决复杂的锁管理问题。如果有问题，欢迎大家在评论区中指出，新人发文，求大佬们轻喷！\n","externalUrl":null,"permalink":"/zh-cn/cpp/rrii/","section":"Cpps","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在多线程编程中，正确管理线程同步是确保程序稳定性和性能的关键。C++ 提供了多种工具来帮助开发者实现线程同步，例如 \u003ccode\u003estd::mutex\u003c/code\u003e、\u003ccode\u003estd::lock_guard\u003c/code\u003e 和 \u003ccode\u003estd::unique_lock\u003c/code\u003e 等。这些工具虽然强大，但在某些复杂场景下，可能需要更灵活的锁管理方式。比如说有的时候我在加锁后，在局部代码中需要释放锁，然后后续运行又需要加锁，这个时候我们虽然可以通过\u003ccode\u003eunlock\u003c/code\u003e和\u003ccode\u003elock\u003c/code\u003e组合完成，但是代码变长后难免会出现遗忘的情况，从而产生错误。那么，本文将介绍一种名为“Antilock”的模式，它能够在需要时暂时释放锁，并在操作完成后自动重新获取锁，从而避免潜在的死锁和遗忘问题。\u003c/p\u003e","title":"临时释放锁：Antilock 模式 (RRII)","type":"cpp"}]